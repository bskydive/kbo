<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Плохие способы использования ngrx/effects</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Плохие способы использования ngrx/effects</h1>
</header>
<section data-field="subtitle" class="p-summary">
Иногда простейшая реализация функционала в конечном итоге создает больше сложности, чем экономит, только перекладывая сложность в другое…
</section>
<section data-field="body" class="e-content">
<section name="b4cc" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3e57" id="3e57" class="graf graf--h3 graf--leading graf--title"><em class="markup--em markup--h3-em">Плохие </em>способы использования <em class="markup--em markup--h3-em">ngrx/effects</em></h3><p name="1819" id="1819" class="graf graf--p graf-after--h3"><a href="https://medium.com/@m3po22/stop-using-ngrx-effects-for-that-a6ccfe186399" data-href="https://medium.com/@m3po22/stop-using-ngrx-effects-for-that-a6ccfe186399" class="markup--anchor markup--p-anchor" target="_blank">Оригинал статьи</a> <a href="https://ngrx.io/docs" data-href="https://ngrx.io/docs" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">Документация ngrx</a> <a href="https://stackblitz.com/edit/rxjs-aj4vwd" data-href="https://stackblitz.com/edit/rxjs-aj4vwd" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">Справочник RxJS</a></p><figure name="b80e" id="b80e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder"><img class="graf-image" data-image-id="1*8l9EG-x40Qo89iJ381cZmg.jpeg" src="https://cdn-images-1.medium.com/max/800/1*8l9EG-x40Qo89iJ381cZmg.jpeg"></div></figure><p name="1a83" id="1a83" class="graf graf--p graf-after--figure">Иногда простейшая реализация функционала в конечном итоге создает больше сложности, чем экономит, только перекладывая сложность в другое место. Конечным результатом является глючная архитектура, которую никто не хочет трогать.</p><p name="d349" id="d349" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Ngrx/store</code> — это библиотека Angular, которая помогает упаковывать сложность отдельных функций. Это происходит в том числе из-за использования в <code class="markup--code markup--p-code">ngrx/store</code> концепций функционального программирования, которые изолируют манипуляции с данными внутри функции. В хранилище (<code class="markup--code markup--p-code">ngrx/store</code>) редукторы (<code class="markup--code markup--p-code">reducer</code>), селекторы (<code class="markup--code markup--p-code">select</code>) и операторы RxJS являются чистыми функциями.</p><p name="7ee0" id="7ee0" class="graf graf--p graf-after--p">Чистые функции легче тестировать, отлаживать, анализировать, распараллеливать и комбинировать. Чистая функция при одинаковых входных данных всегда возвращает одни и те же результаты. Такой подход значительно сокращает ошибки и побочные эффекты.<br>Побочных эффектов невозможно избежать, но они изолированы в <code class="markup--code markup--p-code">ngrx/store</code>, так что остальная часть приложения может состоять из чистых функций.</p><h3 name="7f12" id="7f12" class="graf graf--h3 graf-after--p">Побочные эффекты (side effects)</h3><p name="5365" id="5365" class="graf graf--p graf-after--h3">Когда пользователь отправляет форму, нам нужно внести изменения на сервере. Изменение на сервере и ответ клиенту порождает побочные эффекты. Это может быть обработано внутри компонента следующим образом:</p><figure name="5552" id="5552" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/4b90309f287e482177d07120c3db4a91.js"></script></figure><p name="f7c2" id="f7c2" class="graf graf--p graf-after--figure">Было бы здорово просто отправлять действие (<code class="markup--code markup--p-code">dispatch action</code>) внутри компонента, когда пользователь отправляет форму, и обрабатывать побочный эффект в другом месте.</p><p name="b7c1" id="b7c1" class="graf graf--p graf-after--p">Библиотека эффектов(<code class="markup--code markup--p-code">Ngrx/Effects</code><strong class="markup--strong markup--p-strong">)</strong> — это промежуточный слой(<code class="markup--code markup--p-code">middleware</code>) для обработки побочных эффектов в хранилище (<code class="markup--code markup--p-code">ngrx/store</code>). Она прослушивает отправленные действия в наблюдаемом (<code class="markup--code markup--p-code">Observable</code>) потоке, выполняет побочные эффекты, и возвращает в поток новые действия последовательным или асинхронным образом. Возвращенные действия также передаются в редуктор.</p><p name="4222" id="4222" class="graf graf--p graf-after--p">Возможность обрабатывать побочные эффекты <code class="markup--code markup--p-code">RxJS</code>-дружественным способом делает код чище. После отправки из компонента первого действия с типом <code class="markup--code markup--p-code">SAVE_DATA</code> вы создаете класс эффектов для обработки остальных действий:</p><figure name="fbd3" id="fbd3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/30cd6f35ad9354d7e04a77a82a3475d0.js"></script></figure><p name="4043" id="4043" class="graf graf--p graf-after--figure">Это упрощает работу компонента до отправки действий (dispatch actions) и подписки (subscribe) на наблюдаемые потоки (observables).</p><h3 name="5f1a" id="5f1a" class="graf graf--h3 graf-after--p">Библиотекой Ngrx/Effects легко злоупотребить</h3><p name="5096" id="5096" class="graf graf--p graf-after--h3">Ngrx/Effects — очень мощное решение, поэтому его легко использовать. Вот некоторые распространенные ошибочные способы использования библиотеки эффектов для хранилища состояний:</p><p name="a99f" id="a99f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1. Дублирующее/производное состояние</strong></p><p name="9264" id="9264" class="graf graf--p graf-after--p">Допустим, вы работаете над каким-то проигрывателем, и у вас есть следующие свойства в дереве состояний:</p><figure name="123f" id="123f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/1c16ba0e53464c6bf183b99dc18571cd.js"></script></figure><p name="8763" id="8763" class="graf graf--p graf-after--figure">Поскольку аудио является типом мультимедиа, то вне зависимости от значения <code class="markup--code markup--p-code">audioPlaying</code>, значение <code class="markup--code markup--p-code">mediaPlaying</code> может иметь значение true. Как же убедиться, что <code class="markup--code markup--p-code">mediaPlaying</code> обновляется при обновлении <code class="markup--code markup--p-code">audioPlaying</code>?</p><p name="63d0" id="63d0" class="graf graf--p graf-after--p">Неверный ответ: используйте эффект!</p><figure name="1e99" id="1e99" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/4ec5ebc46d3eb158263a6d33f9cc77f5.js"></script></figure><p name="10d2" id="10d2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Правильный ответ: </strong>если состояние <code class="markup--code markup--p-code">mediaPlaying</code> порождается другим состоянием, то это не истинное, а производное состояние. Оно должно быть в селекторе (select), а не в хранилище.</p><figure name="51d1" id="51d1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/46ea744d93e46ceed41406c2e9981bf4.js"></script></figure><p name="0f2c" id="0f2c" class="graf graf--p graf-after--figure">Теперь наше состояние может оставаться чистым и <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" data-href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">нормализованным</a>, и мы не используем <code class="markup--code markup--p-code">ngrx/Effects</code> для чего-то, что не является побочным эффектом.</p><p name="7a3b" id="7a3b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Связанные действия и редукторы</strong></p><p name="419f" id="419f" class="graf graf--p graf-after--p">Допустим, у вас есть такие свойства в дереве состояний:</p><figure name="1cef" id="1cef" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/239fac4b16eadeee1a10a0c1a82303b8.js"></script></figure><p name="cda9" id="cda9" class="graf graf--p graf-after--figure">Когда пользователь удаляет элемент, то после завершения запроса на удаление, отправляется действие <code class="markup--code markup--p-code">DELETE_ITEM_SUCCESS</code>, чтобы обновить состояние нашего приложения. В редукторе запись удаляется из дерева. Но эта же запись в массиве <code class="markup--code markup--p-code">FavoritesItems</code>, будет ссылаться на удалённую запись в дереве. Как мы можем убедиться при отправке действия <code class="markup--code markup--p-code">DELETE_ITEM_SUCCESS</code>, что соответствующая запись удалена из <code class="markup--code markup--p-code">FavoritesItems</code>?</p><p name="fa6e" id="fa6e" class="graf graf--p graf-after--p">Неверный ответ: используйте эффект!</p><figure name="9942" id="9942" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/c9fec5d14328f5e9d37bfb61e5992ca5.js"></script></figure><p name="aaa2" id="aaa2" class="graf graf--p graf-after--figure">Теперь у нас будет два последовательных действия, и два редуктора, последовательно возвращающие новые состояния.</p><p name="0b8a" id="0b8a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Правильный ответ:</strong> действие <code class="markup--code markup--p-code">DELETE_ITEM_SUCCESS</code> может обрабатываться и редуктором дерева записей, и редуктором массива записей <code class="markup--code markup--p-code">FavoritesItems</code>.</p><figure name="2de5" id="2de5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/9589ae2d41aa013167561ec2ea9fc239.js"></script></figure><p name="aeaa" id="aeaa" class="graf graf--p graf-after--figure">Назначение действий — отделить то, что произошло, от того, как должно измениться состояние. После отправки действия <code class="markup--code markup--p-code">DELETE_ITEM_SUCCESS</code> вызвать соответствующее изменение состояния должен редуктор.</p><p name="4170" id="4170" class="graf graf--p graf-after--p">Удаление записи из массива <code class="markup--code markup--p-code">FavoritesItems</code> не является побочным эффектом удаления элемента. Весь процесс полностью <code class="markup--code markup--p-code">синхронный</code>, и может быть обработан редукторами самостоятельно. Библиотека эффектов не нужна.</p><p name="a258" id="a258" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Выборка данных для компонента</strong></p><p name="02a5" id="02a5" class="graf graf--p graf-after--p">Вашему компоненту нужны данные из хранилища, но данные должны быть сначала получены с сервера. Вопрос в том, как мы можем получить данные в хранилище, чтобы компонент мог их выбрать?</p><p name="d129" id="d129" class="graf graf--p graf-after--p">Болезненный ответ: используйте эффект!</p><p name="570a" id="570a" class="graf graf--p graf-after--p">В компоненте мы инициируем запрос, отправив действие:</p><figure name="8ed8" id="8ed8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/9b83153a63e888ad0e265d2a2fc50cf9.js"></script></figure><p name="8473" id="8473" class="graf graf--p graf-after--figure">В классе эффектов мы слушаем действие <code class="markup--code markup--p-code">GET_USERS</code>:</p><figure name="c7b9" id="c7b9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/252f67a6a14b45df09a2499218621412.js"></script></figure><p name="78a8" id="78a8" class="graf graf--p graf-after--figure">Теперь предположим, что пользователь решает, что загрузка страницы занимает слишком много времени, поэтому он уходит. Чтобы не загружать ненужные данные, мы хотим отменить этот запрос. Когда компонент будет уничтожен, мы отменим подписку на запрос, отправив действие:</p><figure name="c1cb" id="c1cb" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/5952963126524f24c7343b431c05d5cf.js"></script></figure><p name="bb23" id="bb23" class="graf graf--p graf-after--figure">В классе эффектов мы слушаем оба действия:</p><figure name="d0c3" id="d0c3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/013d5aeb1db4351f215ecfe4e83a8214.js"></script></figure><p name="eaa0" id="eaa0" class="graf graf--p graf-after--figure">Теперь другой разработчик добавляет компонент, которому требуется тот же HTTP-запрос (опускаем предположения о других компонентах). Компонент отправляет те же действия в тех же местах. Если оба компонента станут активны одновременно, то первый компонент для инициализации отправит HTTP-запрос. Когда второй компонент инициализируется (<code class="markup--code markup--p-code">ngOnInit</code>), он не будет отправлять запрос, потому что <code class="markup--code markup--p-code">needUsers</code> будет <code class="markup--code markup--p-code">false</code>. Отлично!</p><p name="0b14" id="0b14" class="graf graf--p graf-after--p">Когда первый компонент будет уничтожен, он отправит <code class="markup--code markup--p-code">CANCEL_GET_USERS</code>. Но второй компонент все еще нуждается в этих данных. Как мы можем предотвратить отмену запроса? Может быть, есть счетчик подписчиков (<code class="markup--code markup--p-code">subscribe</code>)? Я не буду беспокоиться об этом, но вы уловили суть. Мы начинаем надеяться, что есть лучший способ управления этими зависимостями данных.</p><p name="6e52" id="6e52" class="graf graf--p graf-after--p">Теперь предположим, что в есть ещё один компонент, и он зависит от данных, которые невозможно получить до тех пор, пока пользовательские данные не появятся в хранилище. Это может быть соединение через веб-сокет для чата, дополнительная информация о некоторых пользователях или что-то еще. Мы не знаем, будет ли этот компонент инициализирован до или после того, как другие два компонента подпишутся на получение данных пользователей.</p><p name="ad55" id="ad55" class="graf graf--p graf-after--p">Лучшее решение, которое я нашел для этого конкретного сценария, — это следующий пример в <a href="https://bertrandg.github.io/ngrx-effects-complex-stream-with-nested-actions/" data-href="https://bertrandg.github.io/ngrx-effects-complex-stream-with-nested-actions/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">отличной статье</a>. Там <code class="markup--code markup--p-code">callApiY</code> требует, чтобы <code class="markup--code markup--p-code">callApiX</code> уже был завершен. Тут убраны комментарии, чтобы код выглядел менее пугающим, но лучше прочитать оригинальный пост, чтобы познакомиться с деталями:</p><figure name="6e36" id="6e36" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/cf5264a17d435abe251fd5b453810012.js"></script></figure><p name="3d48" id="3d48" class="graf graf--p graf-after--figure graf--trailing">Теперь усложним задачу: сделаем так, что HTTP-запросы должны быть отменены, когда компоненты больше не активны.</p></div></div></section><section name="fdab" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="815b" id="815b" class="graf graf--p graf--leading">Почему же так много проблем с управлением зависимостями данных, когда <code class="markup--code markup--p-code">RxJS</code> должен сделать это действительно лёгким?</p><p name="4543" id="4543" class="graf graf--p graf-after--p">Хотя данные, поступающие с сервера, технически являются побочным эффектом, я не верю, что библиотека эффектов — лучший способ управлять зависимостями.</p><p name="bc76" id="bc76" class="graf graf--p graf-after--p">Компоненты — это интерфейсы ввода/вывода для пользователя. Они показывают данные и отправляют действия пользователей. Когда компонент загружается, он не отправляет действие пользователя. Он хочет показать данные. Это похоже на подписку, а не на побочный эффект действия.</p><p name="dabd" id="dabd" class="graf graf--p graf-after--p graf--trailing">Очень часто можно увидеть приложения, использующие действия для запуска запроса на получение данных. Эти приложения реализуют пользовательский интерфейс для наблюдаемых потоков (<code class="markup--code markup--p-code">observables</code>) через побочные эффекты. И, как мы видели, этот интерфейс может стать очень неудобным и громоздким. Подписываться, отписываться, и связывать в цепочки сами наблюдаемые объекты гораздо проще.</p></div></div></section><section name="edff" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0b89" id="0b89" class="graf graf--p graf--leading">Менее болезненный ответ: компонент регистрирует свою заинтересованность в данных, подписываясь на наблюдаемые потоки.</p><p name="8d65" id="8d65" class="graf graf--p graf-after--p">Мы создадим наблюдаемые HTTP-запросы, и увидим насколько проще управлять несколькими подписками и цепочкой запросов разных компонентов используя чистый RxJS, чем библиотеку эффектов.</p><p name="444e" id="444e" class="graf graf--p graf-after--p">Создадим наблюдаемые потоки в сервисе:</p><figure name="cbf0" id="cbf0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/59ef7b52018b9d7ef36c90ecf9b3a313.js"></script></figure><p name="58e5" id="58e5" class="graf graf--p graf-after--figure">Подписки на <code class="markup--code markup--p-code">users$</code> будут передаваться как для <code class="markup--code markup--p-code">requireUsers$</code>, так и для <code class="markup--code markup--p-code">userSelectors.users$</code>, но будут получать значения только от <code class="markup--code markup--p-code">userSelectors.users$</code> (пример реализации <code class="markup--code markup--p-code">muteFirst</code>)</p><p name="86eb" id="86eb" class="graf graf--p graf-after--p">В компоненте:</p><figure name="1f92" id="1f92" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/a8971423780a7d2cd3eb7e97e0ab0c03.js"></script></figure><p name="a99c" id="a99c" class="graf graf--p graf-after--figure">Поскольку эта зависимость данных теперь просто наблюдаемый поток, мы можем подписаться и отписаться в шаблоне, используя асинхронные операторы в <code class="markup--code markup--p-code">pipe()</code>, и нам больше не нужно отправлять действия. Если приложение переходит на <code class="markup--code markup--p-code">url/route</code> другого компонента, подписанного на данные, HTTP-запрос отменяется, а веб-сокет закрывается.</p><p name="dd87" id="dd87" class="graf graf--p graf-after--p">Цепочки зависимостей данных можно обрабатывать так:</p><figure name="fb2f" id="fb2f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/16031078b2fc8c29b43a7ee802fb57fd.js"></script></figure><p name="d9a0" id="d9a0" class="graf graf--p graf-after--figure">Сравним с предыдущим подходом:</p><figure name="a36e" id="a36e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bskydive/cf5264a17d435abe251fd5b453810012.js"></script></figure><p name="e7c2" id="e7c2" class="graf graf--p graf-after--figure">Использование простых наблюдаемых потоков требует меньше строк кода, и автоматически отписывается от зависимостей данных по всей цепочке. (Здесь пропущены строки, приводящие решения в окончательно рабочий вид, чтобы сделать сравнение более понятным, но даже без них запросы по-прежнему отменяются соответствующим образом.)</p><h3 name="eec0" id="eec0" class="graf graf--h3 graf-after--p">Заключение</h3><p name="7394" id="7394" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">Ngrx/Effects</code> — отличный инструмент! Однако необходимо ответить на следующие вопросы прежде чем принять решение о его использовании:</p><ul class="postList"><li name="37e8" id="37e8" class="graf graf--li graf-after--p">Это действительно побочный эффект?</li><li name="d712" id="d712" class="graf graf--li graf-after--li">Действительно ли <code class="markup--code markup--li-code">ngrx/Effects</code> — лучший способ справиться с этим?</li></ul><p name="12af" id="12af" class="graf graf--p graf-after--li">Пожалуйста, поделитесь с <a href="https://medium.com/@m3po22" data-href="https://medium.com/@m3po22" class="markup--anchor markup--p-anchor" target="_blank">нами</a> своим мнением, особенно о любых ошибках. Моя следующая статья опирается на эту. Если я не допустил ошибок, она окажется ещё интереснее.</p><p name="4cc2" id="4cc2" class="graf graf--p graf-after--p"><a href="https://medium.com/@stepanovv.ru/%D0%BD%D0%B0%D1%87%D0%BD%D0%B8%D1%82%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-ngrx-effects-%D0%B4%D0%BB%D1%8F-%D1%8D%D1%82%D0%BE%D0%B3%D0%BE-978994cb4d7c" data-href="https://medium.com/@stepanovv.ru/%D0%BD%D0%B0%D1%87%D0%BD%D0%B8%D1%82%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-ngrx-effects-%D0%B4%D0%BB%D1%8F-%D1%8D%D1%82%D0%BE%D0%B3%D0%BE-978994cb4d7c" class="markup--anchor markup--p-anchor" target="_blank"><em class="markup--em markup--p-em">Хорошие способы использования ngrx/effects</em></a></p><blockquote name="2457" id="2457" class="graf graf--blockquote graf-after--p graf--trailing">Примечание переводчика: примеры кода дополнены комментариями, исправлены незначительные ошибки, текст незначительно сокращён для более литературно красивого перевода.</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@stepanovv.ru" class="p-author h-card">Валерий</a> on <a href="https://medium.com/p/6dec8fa90577"><time class="dt-published" datetime="2019-01-27T20:05:37.070Z">January 27, 2019</time></a>.</p><p><a href="https://medium.com/@stepanovv.ru/%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-%D0%BF%D1%80%D0%B5%D0%BA%D1%80%D0%B0%D1%82%D0%B8%D1%82%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-ngrx-effects-%D0%B4%D0%BB%D1%8F-%D1%8D%D1%82%D0%BE%D0%B3%D0%BE-6dec8fa90577" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 16, 2019.</p></footer></article></body></html>