<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Обрабатываем вызовы api изящным образом</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Обрабатываем вызовы api изящным образом</h1>
</header>
<section data-field="subtitle" class="p-summary">
Оригинал
</section>
<section data-field="body" class="e-content">
<section name="c247" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c5d4" id="c5d4" class="graf graf--h3 graf--leading graf--title">Обрабатываем вызовы api изящным образом</h3><p name="435b" id="435b" class="graf graf--p graf-after--h3"><a href="https://blog.angularindepth.com/handle-api-call-state-nicely-445ab37cc9f8" data-href="https://blog.angularindepth.com/handle-api-call-state-nicely-445ab37cc9f8" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Оригинал</a></p><figure name="110f" id="110f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*AZzaBZuRZG2nkjLo" data-width="5305" data-height="3537" data-unsplash-photo-id="MHZvk_XpK2I" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*AZzaBZuRZG2nkjLo"></div><figcaption class="imageCaption">Фото <a href="https://unsplash.com/@sf_mediach?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@sf_mediach?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener" target="_blank">Sven Fischer</a> из <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p name="9e89" id="9e89" class="graf graf--p graf-after--figure">В этой статье я расскажу о способе обработки состояний для вызовов API и сокращения стандартного шаблона путем сбора общей логики в абстракцию. Этот способ мощный, чистый, и менее подвержен ошибкам. В этой статье предполагается, что мы используем <a href="https://github.com/bskydive/translations/blob/master/articles/handle-api-call-state-nicely/handle-api-call-state-nicely.md" data-href="https://github.com/bskydive/translations/blob/master/articles/handle-api-call-state-nicely/handle-api-call-state-nicely.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">NgRx</a> для управления состоянием.</p><p name="0779" id="0779" class="graf graf--p graf-after--p">Бьюсь об заклад, что наличие API вызовов являются одним из самых распространенных требований для веб-разработки. Многие приложения имеют массу API вызовов. С точки зрения пользовательского опыта всегда полезно указывать состояние вызова API, например, показывать крутилку или сообщение об ошибке. Я видел много способов моделирования состояния вызова API и нашел одну главную проблему: <strong class="markup--strong markup--p-strong">тяжелые заготовки </strong>(<code class="markup--code markup--p-code">boilerplate</code>), которые обычно вызывают дальнейшие проблемы.</p><h3 name="0caa" id="0caa" class="graf graf--h3 graf-after--p">Тяжесть заготовок кода (boilerplate)</h3><p name="ac54" id="ac54" class="graf graf--p graf-after--h3">Предположим следующие бизнес требования:</p><p name="da8e" id="da8e" class="graf graf--p graf-after--p">1. Отправить запрос API, чтобы получить список сегодняшних новостей.<br>2. Показать крутилку во время загрузки<br>3. Показать загруженный список новостей при успешной загрузке.</p><p name="6bae" id="6bae" class="graf graf--p graf-after--p">Многие разработчики проектируют модель состояния с двумя действиями (скажем, <code class="markup--code markup--p-code">LoadNews</code> и <code class="markup--code markup--p-code">LoadNewsSuccess</code>, и двумя обработчиками редуктора для изменения состояния <code class="markup--code markup--p-code">loading</code> и <code class="markup--code markup--p-code">entities</code>).</p><figure name="c565" id="c565" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/d6a5b7b9f2cacf41a2fad2c82bb69737.js"></script></figure><p name="912b" id="912b" class="graf graf--p graf-after--figure">Пока что мы не видим здесь никаких проблем. Это крепкий «стандарт».</p><p name="01d4" id="01d4" class="graf graf--p graf-after--p">Допустим, у нас есть 20 (или даже больше) запросов API в этом приложении. Теперь появляются проблемы:</p><p name="dd42" id="dd42" class="graf graf--p graf-after--p">1. <strong class="markup--strong markup--p-strong">Много заготовок кода.</strong> Нам нужно обработать состояние API <code class="markup--code markup--p-code">loading</code> 20 раз, сделать 40 действий и 40 обработчиков в редукторах. Это много кода с повторяющейся логикой.</p><p name="faef" id="faef" class="graf graf--p graf-after--p">2. <strong class="markup--strong markup--p-strong">Несогласованное именование.</strong> Допустим, 20 вызовов API реализованы 4 разработчиками. Они могут иметь разные соглашения об именах. Например, загрузка может называться <code class="markup--code markup--p-code">isLoading</code>, <code class="markup--code markup--p-code">waiting</code>, <code class="markup--code markup--p-code">isWaiting</code>, <code class="markup--code markup--p-code">started</code> и т. д.</p><p name="3376" id="3376" class="graf graf--p graf-after--p">На самом деле, приведенная выше модель состояния API имеет только одно состояние <code class="markup--code markup--p-code">loading</code>. Однако предполагается, что полный набор будет иметь больше состояний API (о которых пойдет речь в следующем разделе), что сделает предыдущие 2 пункта еще хуже.</p><p name="dfcb" id="dfcb" class="graf graf--p graf-after--p">Давайте решим эту проблему изящно.</p><h3 name="211b" id="211b" class="graf graf--h3 graf-after--p">Что такое полный набор состояний?</h3><p name="24b5" id="24b5" class="graf graf--p graf-after--h3">Полный цикл вызовов API может иметь следующие состояния:</p><p name="5ba6" id="5ba6" class="graf graf--p graf-after--p">1. Вызов API не запущен<br>2. Вызов API начался, но ответа пока нет<br>3. API-вызов получил успешный ответ<br>4. Вызов API получил ответ об ошибке</p><p name="c364" id="c364" class="graf graf--p graf-after--p">Таким образом, мы можем спроектировать общую модель загрузки следующим образом (назовем ее <code class="markup--code markup--p-code">Loadable</code>):</p><figure name="3458" id="3458" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/62aa2e016985146aebdafe9975bf1096.js"></script></figure><p name="d48c" id="d48c" class="graf graf--p graf-after--figure">4 состояния легко сопоставить со значениями 3 полей.</p><p name="e2d3" id="e2d3" class="graf graf--p graf-after--p">Я бы также создал 4 простых вспомогательных функции для обновления загружаемого состояния. Обратите внимание, что они являются чистыми функциями и возвращают новые объекты <code class="markup--code markup--p-code">loadable</code>:</p><figure name="9a52" id="9a52" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/ff778eb6a6293113da7faa3de0a12f66.js"></script></figure><h3 name="444a" id="444a" class="graf graf--h3 graf-after--figure">Применим <code class="markup--code markup--h3-code">loadable</code> к нашему примеру загрузки списка новостей</h3><h4 name="45b3" id="45b3" class="graf graf--h4 graf-after--h3">Модель</h4><p name="6660" id="6660" class="graf graf--p graf-after--h4">Помимо 3 полей <code class="markup--code markup--p-code">loadable</code>, нам нужно еще одно состояние для хранения списка новостей, которые мы получили от API. Итак, мы можем предположить следующую модель:</p><figure name="aa0f" id="aa0f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/96d6d97982982902eebac2a67c54b0de.js"></script></figure><h4 name="cfb0" id="cfb0" class="graf graf--h4 graf-after--figure">Действия (actions)</h4><p name="4879" id="4879" class="graf graf--p graf-after--h4">Действия остаются такими же, как в соглашениях ngrx.</p><figure name="3693" id="3693" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/f072c49ad3c96608706a1856db83a88e.js"></script></figure><h4 name="9c9f" id="9c9f" class="graf graf--h4 graf-after--figure">Редуктор (reducer)</h4><p name="4828" id="4828" class="graf graf--p graf-after--h4">Мы используем редуктор, чтобы изменить состояние в соответствии с 3 различными действиями.</p><figure name="3580" id="3580" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/7925f8974782385c0ff1ec3cb51e3143.js"></script></figure><h4 name="1c1f" id="1c1f" class="graf graf--h4 graf-after--figure">Побочные эффекты (effects)</h4><figure name="2bba" id="2bba" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vvscode/c7859854ffb5730c0c795b80999dbf92.js"></script></figure><h4 name="28b4" id="28b4" class="graf graf--h4 graf-after--figure">UI Component</h4><figure name="869c" id="869c" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vvscode/c2dba4384244345b18f794a39cb7354c.js"></script></figure><p name="5d98" id="5d98" class="graf graf--p graf-after--figure">Кода достаточно, чтобы заставить его работать. Тем не менее, это помогает только обеспечить согласованное именование за счет наследования <code class="markup--code markup--p-code">loadable</code>, и помогает убедиться в правильности изменения состояния с помощью вспомогательных функций. Это действительно не уменьшает шаблон. Представьте, что если у нас есть 20 вызовов API, нам все равно нужно обрабатывать каждое действие (<code class="markup--code markup--p-code">load</code>, <code class="markup--code markup--p-code">loadSuccess</code>, <code class="markup--code markup--p-code">loadError</code>) в каждом из 20 редукторов. И 20 из них имеют одинаковую логику смены состояний. (то есть <code class="markup--code markup--p-code">loading</code> <code class="markup--code markup--p-code">success</code> <code class="markup--code markup--p-code">error</code>)</p><h4 name="b75c" id="b75c" class="graf graf--h4 graf-after--p">Абстрактная логика изменения состояния API для редуктора</h4><p name="5816" id="5816" class="graf graf--p graf-after--h4">Давайте определим функцию более высокого порядка <code class="markup--code markup--p-code">withLoadable</code>, которая принимает в качестве параметров редуктор, три строки типа действия, и возвращает новый улучшенный редуктор.</p><figure name="02ef" id="02ef" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/693f36f8729b9833cc019c7114166342.js"></script></figure><p name="5ac2" id="5ac2" class="graf graf--p graf-after--figure">Таким образом, редуктор для новостей может быть таким:</p><figure name="99ce" id="99ce" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/1217a30f324807841bfd8a321ea87e11.js"></script></figure><p name="1c81" id="1c81" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">baseNewsReducer</code> обрабатывает не <code class="markup--code markup--p-code">loadable</code> состояния (то есть <code class="markup--code markup--p-code">entities</code>)</p><p name="4971" id="4971" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">newsReducer</code> на самом деле будет применять <code class="markup--code markup--p-code">withLoadable</code> к <code class="markup--code markup--p-code">baseReducer</code>, чтобы придать <code class="markup--code markup--p-code">baseReducer</code> немного «магии», т.е. способность <strong class="markup--strong markup--p-strong">автоматически</strong> обрабатывать изменения состояния <code class="markup--code markup--p-code">loadable</code>.</p><p name="c399" id="c399" class="graf graf--p graf-after--p">Таким образом, если у нас есть 20 вызовов API, и мы хотим сохранить все 20 * 3 = 60 состояний, мы можем просто применить <code class="markup--code markup--p-code">withLoadable</code> к 20 базовым редукторам. В 20 базовых редукторах нас не волнует, как должно обновляться состояние <code class="markup--code markup--p-code">loadable</code>. Таким образом, это экономит нам много времени на ручное обновление состояния API.</p><h4 name="7037" id="7037" class="graf graf--h4 graf-after--p">Бонус: подключение <code class="markup--code markup--h4-code">Loadable </code>в компонент пользовательского интерфейса</h4><p name="71df" id="71df" class="graf graf--p graf-after--h4">На самом деле <code class="markup--code markup--p-code">Loadable</code> обеспечивает действительно согласованный контракт, так что он может быть беспрепятственно связан с глобальным компонентом пользовательского интерфейса. Например, я могу создать общий <code class="markup--code markup--p-code">loadable-container</code> компонента для обработки пользовательского интерфейса загрузки, глобальный интерфейс ошибок. И единственный контракт с внешним миром — это просто <code class="markup--code markup--p-code">Loadable</code> в <code class="markup--code markup--p-code"><a href="http://twitter.com/Input" data-href="http://twitter.com/Input" class="markup--anchor markup--p-anchor" title="Twitter profile for @Input" rel="noopener" target="_blank">@Input</a></code></p><figure name="5496" id="5496" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/d69ebd7a35376d8336a0190e5397ad3c.js"></script></figure><p name="128d" id="128d" class="graf graf--p graf-after--figure">Это позволит нам показывать каждую крутилку/ошибку вызова API, просто используя этот компонент <code class="markup--code markup--p-code">loadable-container</code>, что также экономит множество кода в шаблонах.</p><figure name="9b54" id="9b54" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vvscode/6cf2e112ab59a80999867376fce228a5.js"></script><figcaption class="imageCaption">HTML код компонента</figcaption></figure><p name="11e9" id="11e9" class="graf graf--p graf-after--figure">Пожалуйста, посмотрите окончательный код в <a href="https://stackblitz.com/github/zhaosiyang/loadable-example" data-href="https://stackblitz.com/github/zhaosiyang/loadable-example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">StackBlitz</a> или в <a href="https://github.com/zhaosiyang/loadable-example" data-href="https://github.com/zhaosiyang/loadable-example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github Repo</a>. Единственное отличие от кода статьи в том, что он более строго организован, чтобы показать лучшие практики кодирования в реальной жизни. Кроме того, он использует ложный вызов API для получения списка новостей.</p><p name="d55b" id="d55b" class="graf graf--p graf-after--p">Если вы хотите использовать его в своем проекте, у меня есть пакет <code class="markup--code markup--p-code">npm</code> для вас. Смотрите <a href="https://www.npmjs.com/package/loadable-state" data-href="https://www.npmjs.com/package/loadable-state" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">тут</a>.</p><blockquote name="9d00" id="9d00" class="graf graf--blockquote graf-after--p graf--trailing">Примечание переводчика: примеры кода дополнены комментариями, исправлены незначительные ошибки, текст незначительно сокращён для более литературно красивого перевода.</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@stepanovv.ru" class="p-author h-card">Валерий</a> on <a href="https://medium.com/p/98d537eed04c"><time class="dt-published" datetime="2019-02-02T21:25:31.201Z">February 2, 2019</time></a>.</p><p><a href="https://medium.com/@stepanovv.ru/%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D0%B5%D0%BC-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D1%8B-api-%D0%B8%D0%B7%D1%8F%D1%89%D0%BD%D1%8B%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-98d537eed04c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 16, 2019.</p></footer></article></body></html>