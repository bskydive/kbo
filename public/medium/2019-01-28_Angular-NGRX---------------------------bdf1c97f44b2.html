<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Angular/NGRX — ясное и чёткое введение</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Angular/NGRX — ясное и чёткое введение</h1>
</header>
<section data-field="description" class="p-summary">
Дополненный и исправленный перевод
</section>
<section data-field="body" class="e-content">
<section name="4128" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ce99" id="ce99" class="graf graf--h3 graf--leading graf--title">Angular/NGRX — ясное и чёткое введение</h3><p name="feef" id="feef" class="graf graf--p graf-after--h3"><a href="https://medium.com/frontend-fun/angular-ngrx-a-clean-and-clear-introduction-4ed61c89c1fc" data-href="https://medium.com/frontend-fun/angular-ngrx-a-clean-and-clear-introduction-4ed61c89c1fc" class="markup--anchor markup--p-anchor" target="_blank">Оригинал статьи</a> <a href="https://github.com/SantiagoGdaR/angular-ngrx" data-href="https://github.com/SantiagoGdaR/angular-ngrx" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">репозиторий GitHub</a> <a href="https://ngrx.io/docs" data-href="https://ngrx.io/docs" class="markup--anchor markup--p-anchor" rel="noopener nofollow noopener" target="_blank">Документация ngrx</a> <a href="https://stackblitz.com/edit/rxjs-aj4vwd" data-href="https://stackblitz.com/edit/rxjs-aj4vwd" class="markup--anchor markup--p-anchor" rel="noopener nofollow noopener" target="_blank">Справочник RxJS</a></p><figure name="cbe3" id="cbe3" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 432px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 61.8%;"></div><img class="graf-image" data-image-id="1*Xef12zCLy_g4z74XbHZuSg.png" data-width="800" data-height="494" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Xef12zCLy_g4z74XbHZuSg.png"></div></figure><p name="3271" id="3271" class="graf graf--p graf-after--figure">Цель этой статьи — дать ясное и понятное введение в <strong class="markup--strong markup--p-strong">ngrx</strong>. Я объясню, что вам нужно знать об ngrx, а затем проиллюстрирую это с помощью нескольких простых и понятных примеров кода.</p><p name="2e0c" id="2e0c" class="graf graf--p graf-after--p">В конце будет ссылка на репозиторий GitHub, чтобы вы могли поиграться с кодом.</p><p name="1e51" id="1e51" class="graf graf--p graf-after--p">Вот что мы рассмотрим:</p><ul class="postList"><li name="416b" id="416b" class="graf graf--li graf-after--p">Что такое ngrx</li><li name="840f" id="840f" class="graf graf--li graf-after--li"><a href="https://medium.com/p/bdf1c97f44b2#2c50" data-href="https://medium.com/p/bdf1c97f44b2#2c50" class="markup--anchor markup--li-anchor" target="_blank">Преимущества использования ngrx</a></li><li name="4b91" id="4b91" class="graf graf--li graf-after--li"><a href="https://medium.com/p/bdf1c97f44b2#7d9f" data-href="https://medium.com/p/bdf1c97f44b2#7d9f" class="markup--anchor markup--li-anchor" target="_blank">Недостатки использования ngrx</a></li><li name="3634" id="3634" class="graf graf--li graf-after--li"><a href="https://medium.com/p/bdf1c97f44b2#ee20" data-href="https://medium.com/p/bdf1c97f44b2#ee20" class="markup--anchor markup--li-anchor" target="_blank">Когда стоит использовать ngrx</a></li><li name="248f" id="248f" class="graf graf--li graf-after--li"><a href="https://medium.com/p/bdf1c97f44b2#63b4" data-href="https://medium.com/p/bdf1c97f44b2#63b4" class="markup--anchor markup--li-anchor" target="_blank">Действия, Редукторы, Селекторы, Хранилище и Эффекты</a></li><li name="a0b1" id="a0b1" class="graf graf--li graf-after--li"><a href="https://medium.com/p/bdf1c97f44b2#454f" data-href="https://medium.com/p/bdf1c97f44b2#454f" class="markup--anchor markup--li-anchor" target="_blank">Пример использования NGRX</a></li></ul><p name="c833" id="c833" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">ngrx </strong>—<strong class="markup--strong markup--p-strong"> </strong>это группа библиотек, «вдохновленная» библиотекой <code class="markup--code markup--p-code">Redux</code>, которая, в свою очередь, «вдохновлена» шаблоном <code class="markup--code markup--p-code">Flux</code>. Это означает, что шаблон <code class="markup--code markup--p-code">Redux</code> является упрощенной версией шаблона <code class="markup--code markup--p-code">Flux</code>, а <code class="markup--code markup--p-code">NGRX</code> является версией шаблона <code class="markup--code markup--p-code">redux </code>с использованием Angular и RxJS.</p><blockquote name="781a" id="781a" class="graf graf--blockquote graf-after--p">Что я подразумеваю под «<code class="markup--code markup--blockquote-code">angular/rxjs</code>» версией <code class="markup--code markup--blockquote-code">redux</code>…</blockquote><blockquote name="ac04" id="ac04" class="graf graf--blockquote graf-after--blockquote">«<code class="markup--code markup--blockquote-code">Angular</code>» — потому что <code class="markup--code markup--blockquote-code">ngrx</code> — это библиотека для использования в <code class="markup--code markup--blockquote-code">Angular</code> приложениях.</blockquote><blockquote name="4fb9" id="4fb9" class="graf graf--blockquote graf-after--blockquote">«<code class="markup--code markup--blockquote-code">rxjs</code>» — потому что реализация <code class="markup--code markup--blockquote-code">ngrx</code> работает с использованием потоков <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">observables</em></code>, и различных операторов, предоставляемых «<code class="markup--code markup--blockquote-code">rxjs</code>».</blockquote><p name="e3a0" id="e3a0" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Главная цель этого шаблона — соорудить контейнер для состояний, работающий по строгим правилам. Они основаны на трёх принципах.</strong></p><p name="4fbb" id="4fbb" class="graf graf--p graf-after--p">Давайте пройдемся по трем принципам библиотеки <code class="markup--code markup--p-code">Redux</code>, и укажем на наиболее важные преимущества, которые они предоставляют.</p><h4 name="5fde" id="5fde" class="graf graf--h4 graf-after--p">Единый источник правды</h4><p name="d767" id="d767" class="graf graf--p graf-after--h4">Для архитектуры redux и ngrx это означает, что состояние всего вашего приложения хранится в древовидном объекте, — в одном хранилище.</p><blockquote name="54ec" id="54ec" class="graf graf--blockquote graf-after--p">Что значит в одном хранилище? Позже мы поговорим о хранилище, но в общем случае оно несёт ответственность за сохранение состояния и применение к нему изменений, когда ему говорят об этом (например, когда отправляется действие - мы рассмотрим это позже).</blockquote><p name="30af" id="30af" class="graf graf--p graf-after--blockquote">Преимущества наличия единственного источника правды более чем <a href="https://redux.js.org/introduction/threeprinciples" data-href="https://redux.js.org/introduction/threeprinciples" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">достаточны</a>, но поскольку он будет влиять на любое приложение <code class="markup--code markup--p-code">angular</code>, для меня более интересно следующее:</p><ul class="postList"><li name="0776" id="0776" class="graf graf--li graf-after--p">Когда вы создаете приложение <code class="markup--code markup--li-code">angular</code>, вы обычно разделяете состояние, и обрабатываете их в разных сервисах. По мере того как ваше приложение растёт, отслеживание изменения состояний становится беспорядочным, их трудно отлаживать и поддерживать. Наличие единственного источника правды решает эту проблему, поскольку состояние обрабатывается только в одном объекте и в одном месте, поэтому отладка или добавление изменений становится намного проще.</li></ul><h4 name="a756" id="a756" class="graf graf--h4 graf-after--li">Состояние только для чтения</h4><p name="cb80" id="cb80" class="graf graf--p graf-after--h4">Вы никогда не изменяете состояние (<code class="markup--code markup--p-code">state</code>) напрямую, вместо этого вы отправляете действия (<code class="markup--code markup--p-code">dispatch actions</code>). Эти действия описывают, что происходит. Например: получение, добавление, удаление, обновление состояния.</p><blockquote name="ed0b" id="ed0b" class="graf graf--blockquote graf-after--p">Отправка действия? … Мы поговорим об этом позже, но в основном они являются идентификаторами операции в вашем приложении, и могут быть вызваны/отправлены (<code class="markup--code markup--blockquote-code">triggered/dispatched</code>), чтобы попросить приложение выполнить операцию, которую описывает действие.</blockquote><p name="e892" id="e892" class="graf graf--p graf-after--blockquote">Вы получаете много преимуществ, избегая обновления состояния из разных мест, и имея централизованное место для внесения изменений, которое реагирует на конкретные действия. Вот самые важные из них:</p><ul class="postList"><li name="cc00" id="cc00" class="graf graf--li graf-after--p">Вы знаете, что любое изменение в состоянии произойдет только в одном месте. Это сильно облегчает отладку и тестирование.</li><li name="f9e7" id="f9e7" class="graf graf--li graf-after--li">Вы знаете, что при отправке определенного действия операция в состоянии всегда одинакова. Опять же, это облегчает отладку и тестирование.</li></ul><h4 name="42fe" id="42fe" class="graf graf--h4 graf-after--li">Изменения делаются чистыми функциями</h4><p name="4db6" id="4db6" class="graf graf--p graf-after--h4">Операция, инициируемая отправкой действия, будет чистой функцией, называемой в архитектуре <code class="markup--code markup--p-code">redux</code> — <code class="markup--code markup--p-code">reducer</code> (редукторами).</p><p name="517b" id="517b" class="graf graf--p graf-after--p">Эти редукторы (просто чистые функции) получают действие (<code class="markup--code markup--p-code">action</code>) и состояние (<code class="markup--code markup--p-code">state</code>), в зависимости от отправленного действия (обычно отфильтрованного оператором <code class="markup--code markup--p-code">switch</code>), они выполняют операцию и возвращают новый объект состояния.</p><blockquote name="37ef" id="37ef" class="graf graf--pullquote graf-after--p">Состояние в redux приложении является неизменным (immutable)! Поэтому, когда редуктор (reducer) изменяет что-либо в состоянии, он возвращает новый объект состояния.</blockquote><p name="642a" id="642a" class="graf graf--p graf-after--pullquote">Преимущества использования чистых функций хорошо известны, например то что они сразу готовы к тестированию. Если вы передадите те же аргументы, то получите тот же результат.</p><p name="124e" id="124e" class="graf graf--p graf-after--p">Этот подход также позволяет нам перемещаться между различными экземплярами нашего состояния с помощью инструментов разработки <code class="markup--code markup--p-code">Redux/ngrx</code> и видеть, что изменилось между экземплярами, кто их изменил, и многое другое. Поэтому использование чистых функций и возвращение новых экземпляров состояния также значительно облегчает отладку.</p><p name="2f26" id="2f26" class="graf graf--p graf-after--p">Но главное преимущество, на мой взгляд, заключается в том, что, привязав все входные данные наших компонентов к свойствам состояния (<code class="markup--code markup--p-code">state</code>), мы можем изменить стратегию обнаружения изменений (<code class="markup--code markup--p-code">angular/zoneJS change detection</code>) на <code class="markup--code markup--p-code">onPush</code>, и это улучшит производительность приложения.</p><h4 name="2c50" id="2c50" class="graf graf--h4 graf-after--p">Отлично … так каковы же преимущества использования NGRX</h4><p name="a40f" id="a40f" class="graf graf--p graf-after--h4">Мы уже упоминали большинство из них, когда говорили о принципах шаблона <code class="markup--code markup--p-code">Redux</code>. Но давайте отметим наиболее важные преимущества использования шаблона <code class="markup--code markup--p-code">Redux</code> в приложении (на взгляд автора):</p><ul class="postList"><li name="285f" id="285f" class="graf graf--li graf-after--p">Поскольку у нас есть один источник правды, и вы не можете напрямую изменить состояние, приложения будут работать более согласованно.</li><li name="74de" id="74de" class="graf graf--li graf-after--li">Использование шаблона <code class="markup--code markup--li-code">Redux</code> дает нам много интересных функций (<code class="markup--code markup--li-code">dev tools</code>), облегчающих отладку.</li><li name="9e6b" id="9e6b" class="graf graf--li graf-after--li">Тестирование приложений становится проще, поскольку мы вводим чистые функции для обработки изменений состояния, а также потому, что и <code class="markup--code markup--li-code">ngrx</code><strong class="markup--strong markup--li-strong">,</strong> и <code class="markup--code markup--li-code">rxjs</code>, имеют множество замечательных возможностей для тестирования.</li><li name="5a2e" id="5a2e" class="graf graf--li graf-after--li">Как только вы почувствуете себя комфортно при использовании <code class="markup--code markup--li-code">ngrx</code>, понимание потока данных в ваших приложениях станет невероятно простым и предсказуемым.</li></ul><h4 name="7d9f" id="7d9f" class="graf graf--h4 graf-after--li">… и недостатки</h4><ul class="postList"><li name="d0a7" id="d0a7" class="graf graf--li graf-after--h4">У <code class="markup--code markup--li-code">NGRX</code>, конечно, есть кривая обучения. Не большая, но и не такая маленькая, и я думаю, что это требует некоторого опыта или глубокого понимания некоторых программных шаблонов. Это не является проблемой для любого разработчик среднего уровня, но младший может поначалу немного запутаться.</li><li name="8bc4" id="8bc4" class="graf graf--li graf-after--li">Для меня это ощущается немного многословно (прим пер.: речь о проблеме множества заготовок кода — <code class="markup--code markup--li-code">heavy boilerplate</code>). Поэтому каждый раз, когда вы добавляете какое-либо свойство в состояние (<code class="markup--code markup--li-code">state property</code>), вам нужно добавлять действия (<code class="markup--code markup--li-code">actions</code>) и диспетчеры (<code class="markup--code markup--li-code">dispatchers</code>). Вам может потребоваться обновить или добавить селекторы (<code class="markup--code markup--li-code">selectors</code>), эффекты (<code class="markup--code markup--li-code">effects</code>), если таковые имеются, и обновить хранилище (<code class="markup--code markup--li-code">store</code>). Кроме того, вы будете собирать конвейер (<code class="markup--code markup--li-code">pipe</code>) операторов <code class="markup--code markup--li-code">rxjs</code> и наблюдаемых потоков (<code class="markup--code markup--li-code">observables</code>) везде где это потребуется.</li><li name="4735" id="4735" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">NGRX</code> не является частью библиотек <code class="markup--code markup--li-code">Angular core</code>, и не поддерживается Google. По крайней мере, не напрямую, потому что среди контрибьюторов <code class="markup--code markup--li-code">ngrx</code><strong class="markup--strong markup--li-strong"> </strong>есть разработчики из команды <code class="markup--code markup--li-code">Angular</code>. Это ещё один пункт для обдумывания — вы добавляете в зависимости тяжёлую библиотеку.</li></ul><h4 name="ee20" id="ee20" class="graf graf--h4 graf-after--li">Когда использовать NGRX</h4><p name="f839" id="f839" class="graf graf--p graf-after--h4">Итак, по общему мнению, <code class="markup--code markup--p-code">ngrx</code> следует использовать в средних/крупных проектах, где управление состоянием становится трудным в обслуживании. Те кто фанатеют по шаблонам (<code class="markup--code markup--p-code">pattern</code>) скажут что-то вроде «если у вас есть состояние, у вас есть <code class="markup--code markup--p-code">NGRX</code>».</p><p name="6baf" id="6baf" class="graf graf--p graf-after--p">Я согласен, что его следует использовать в средних или крупных проектах, когда у вас есть значительное количество состояний, и множество компонентов, использующих эти состояния. Но вы должны учитывать, что <code class="markup--code markup--p-code">Angular</code> сам по себе предоставляет множество решений для управления состоянием. Если у вас есть сильная команда разработчиков, то, возможно, вам не нужно беспокоиться о <code class="markup--code markup--p-code">ngrx</code>.</p><p name="9cb0" id="9cb0" class="graf graf--p graf-after--p">При этом я считаю, что сильная команда разработчиков <code class="markup--code markup--p-code">Angular</code> может решить использовать <code class="markup--code markup--p-code">ngrx</code> в проекте потому что они знают силу шаблона <code class="markup--code markup--p-code">Redux</code> и операторов <code class="markup--code markup--p-code">rxjs</code>. И они чувствуют себя комфортно, работая и с тем, и с другим …</p><blockquote name="5a85" id="5a85" class="graf graf--pullquote graf-after--p">Если вы ожидали простого ответа, чтобы решить, когда использовать <strong class="markup--strong markup--pullquote-strong">ngrx</strong>, вы не получите его, и не доверяйте никому, кто дает вам этот ответ за пределами вашей организации или команды. Решение зависит от изучения плюсов и минусов, понимания возможностей вашей команды, и учета их мнения.</blockquote><h4 name="63b4" id="63b4" class="graf graf--h4 graf-after--pullquote">Действия (actions), редукторы (reducer), селекторы (select), хранилище (store) и побочные эффекты (effects) NGRX</h4><p name="301d" id="301d" class="graf graf--p graf-after--h4">Это основные строительные единицы жизненного цикла <code class="markup--code markup--p-code">ngrx</code>. Каждый из них берет на себя часть процесса от запуска операции до изменения нашего состояния и извлечения данных.</p><figure name="15dd" id="15dd" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 631px; max-height: 425px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 67.4%;"></div><img class="graf-image" data-image-id="1*s3oCQSfwACyyioKaST_xTQ.png" data-width="631" data-height="425" src="https://cdn-images-1.medium.com/max/800/1*s3oCQSfwACyyioKaST_xTQ.png"></div></figure><p name="d7ab" id="d7ab" class="graf graf--p graf-after--figure">На этой картинке мы видим жизненный цикл ngrx. Давайте разберём его …</p><p name="757f" id="757f" class="graf graf--p graf-after--p">1. В наиболее распространенном сценарии все начинается в представлении компонента (<code class="markup--code markup--p-code">component view</code>). Взаимодействие с пользователем может привести к тому, что компонент отправит действие (<code class="markup--code markup--p-code">dispatch action</code>).</p><blockquote name="ccd7" id="ccd7" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Действия (</strong><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong">actions</strong></code><strong class="markup--strong markup--blockquote-strong">)…</strong><br>В объекте хранилища (<code class="markup--code markup--blockquote-code">store object</code>) у вас есть функция для отправки/запуска (<code class="markup--code markup--blockquote-code">dispatch/trigger</code>) действий. Действия — это классы, которые реализуют интерфейс действий <code class="markup--code markup--blockquote-code">NGRX/Actions</code>. Эти классы действий имеют два свойства (давайте возьмем в качестве примера класс действия с именем <code class="markup--code markup--blockquote-code">GetUserName</code>):</blockquote><blockquote name="66a9" id="66a9" class="graf graf--blockquote graf-after--blockquote">тип (<code class="markup--code markup--blockquote-code">type</code>): это обычная строка только для чтения, описывающая, что означает действие. Например: ‘[User] Get User Name’</blockquote><blockquote name="19a5" id="19a5" class="graf graf--blockquote graf-after--blockquote">Полезная нагрузка (<code class="markup--code markup--blockquote-code">payload</code>): тип этого свойства зависит от того, какой тип данных это действие необходимо отправить редуктору (<code class="markup--code markup--blockquote-code">reducer</code>). В случае с предыдущим примером это будет строка, содержащая имя пользователя. Не все действия требуют полезной нагрузки.</blockquote><p name="ca61" id="ca61" class="graf graf--p graf-after--blockquote">2.1. Если действие не вызывает эффект (<code class="markup--code markup--p-code">trigger effect</code>), то редуктор отфильтрует действие (обычно с помощью оператора switch), и вернёт новое состояние, которое будет результатом слияния старого состояния со значением, которое изменилось после вызова действия.</p><blockquote name="0eee" id="0eee" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Редукторы (reducers)…</strong></blockquote><blockquote name="38c6" id="38c6" class="graf graf--blockquote graf-after--blockquote">Редукторы — это чистые функции, принимающие два аргумента: предыдущее состояние (<code class="markup--code markup--blockquote-code">state</code>) и действие (<code class="markup--code markup--blockquote-code">action</code>). Когда отправляется действие, <code class="markup--code markup--blockquote-code">ngrx</code> проходит через все редукторы, передавая в качестве аргументов предыдущее состояние и действие, в порядке, в котором редукторы были созданы, пока не найдет обработчик для этого действия.</blockquote><p name="607d" id="607d" class="graf graf--p graf-after--blockquote">2.2. Если действие вызвало эффект, то это говорит о необходимости обработки побочных эффектов перед вызовом редуктора. Это может быть что-то вроде вызова службы HTTP для получения данных.</p><blockquote name="329c" id="329c" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Эффекты (effects)…</strong></blockquote><blockquote name="f54f" id="f54f" class="graf graf--blockquote graf-after--blockquote">Эффекты в экосистеме библиотек <code class="markup--code markup--blockquote-code">ngrx</code> позволяют нам иметь дело с побочными эффектами (прим. пер.: обычно это функция изменения состояния данных), вызванными отправкой действия вне компонентов <code class="markup--code markup--blockquote-code">Angular</code> или хранилища <code class="markup--code markup--blockquote-code">ngrx</code>.</blockquote><blockquote name="b3da" id="b3da" class="graf graf--blockquote graf-after--blockquote">Эффекты прослушивают отправленные действия, и, также как и редукторы, проверяют, имеются ли у них обработчик для них. Затем выполняется побочный эффект. Обычно это получение или отправка данных посредством API.</blockquote><blockquote name="eac2" id="eac2" class="graf graf--blockquote graf-after--blockquote">Потом будет выполнено следующее действие, обычно относящееся к результирующему состоянию побочного эффекта (успех, ошибка отправки данных, и т. д.). Затем действие обрабатывает редуктор. Мы уже упоминали это в описании жизненного цикла ngrx.</blockquote><p name="7508" id="7508" class="graf graf--p graf-after--blockquote">2.2.1. После того, как эффект отработал (побочные эффекты закончились), он запускает новое действие «состояние-результат» (побочные эффекты могут быть успешными или неудачными), и мы возвращаемся к пункту 2.1.</p><p name="8496" id="8496" class="graf graf--p graf-after--p">3. Теперь у хранилища есть новое состояние. Состояние может быть большим деревом — объектом, поэтому <code class="markup--code markup--p-code">ngrx</code> вводит селекторы, чтобы иметь возможность использовать только необходимые фрагменты объекта.</p><blockquote name="bb46" id="bb46" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Селекторы (select) …</strong></blockquote><blockquote name="07ce" id="07ce" class="graf graf--blockquote graf-after--blockquote">Как мы упоминали ранее, дерево состояний может стать довольно большим объектом, и не имеет смысла размещать весь этот объект там, где нужна только его часть.</blockquote><blockquote name="6469" id="6469" class="graf graf--blockquote graf-after--blockquote">Хранилище NGRX предоставляет нам функцию «селектор» для получения фагментов нашего хранилища. А если нам нужно применить некоторую логику к этому фрагменту перед использованием данных в компонентах?</blockquote><blockquote name="524b" id="524b" class="graf graf--blockquote graf-after--blockquote">Здесь в игру вступают селекторы. Они позволяют нам обрабатывать данные фрагмента состояния вне компонента. Функция «<code class="markup--code markup--blockquote-code">select</code>» хранилища принимает в качестве аргумента чистую функцию, она и является нашим селектором.</blockquote><blockquote name="762d" id="762d" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Хранилище (store)…</strong></blockquote><blockquote name="8f4c" id="8f4c" class="graf graf--blockquote graf-after--blockquote">Хранилище — это объект (экземпляр класса <code class="markup--code markup--blockquote-code">ngrx/Store</code>), который объединяет вещи, о которых мы упоминали ранее (действия, редукторы, селекторы). Например, когда через его функции отправляется действие,то хранилище находит и выполняет соответствующий редуктор.<br>Оно также хранит состояние приложения.</blockquote><h4 name="454f" id="454f" class="graf graf--h4 graf-after--blockquote">Пример использования NGRX</h4><p name="b4bb" id="b4bb" class="graf graf--p graf-after--h4">Итак, мы закончили с теорией, представив жизненный цикл <code class="markup--code markup--p-code">ngrx</code> и его участников, а теперь пришло время посмотреть на это в действии. Из этого легко сделать ещё одну статью. Но, на мой взгляд, нет смысла объяснять всё то, что мы объяснили без примеров реализации. Так мы можем посмотреть всё в действии, скачать и поиграться с кодом.</p><p name="c441" id="c441" class="graf graf--p graf-after--p">В нашем примере будет список пользователей, страница сведений о пользователе, и некоторая начальная информация о конфигурации, которую вы должны получить при запуске приложения. Мы собираемся реализовать некоторые важные этапы жизненного цикла <code class="markup--code markup--p-code">ngrx</code>.</p><p name="d41e" id="d41e" class="graf graf--p graf-after--p">Вот что это будет:</p><ul class="postList"><li name="4086" id="4086" class="graf graf--li graf-after--p">Установить библиотеки <code class="markup--code markup--li-code">ngrx</code></li><li name="3568" id="3568" class="graf graf--li graf-after--li">Создать структуру папок для хранилища <code class="markup--code markup--li-code">Store</code></li><li name="f418" id="f418" class="graf graf--li graf-after--li">Создать состояние <code class="markup--code markup--li-code">State</code> и начальные значения</li><li name="ada2" id="ada2" class="graf graf--li graf-after--li">Создать действия <code class="markup--code markup--li-code">Actions</code></li><li name="27a1" id="27a1" class="graf graf--li graf-after--li">Создать редукторы <code class="markup--code markup--li-code">Reducers</code></li><li name="f279" id="f279" class="graf graf--li graf-after--li">Создать эффекты <code class="markup--code markup--li-code">Effects</code></li><li name="96e0" id="96e0" class="graf graf--li graf-after--li">Создать селекторы <code class="markup--code markup--li-code">Selectors</code></li><li name="5c60" id="5c60" class="graf graf--li graf-after--li">Собрать и настроить всё вместе</li><li name="da94" id="da94" class="graf graf--li graf-after--li">Использовать хранилище в некоторых компонентах</li></ul><p name="033d" id="033d" class="graf graf--p graf-after--li">Итак, приступим …</p><h4 name="d112" id="d112" class="graf graf--h4 graf-after--p">Установка библиотеки</h4><p name="7a44" id="7a44" class="graf graf--p graf-after--h4">Мы собираемся использовать <code class="markup--code markup--p-code">Angular Cli</code> для создания проекта, а затем добавить библиотеки <code class="markup--code markup--p-code">ngrx</code>.</p><p name="c4f2" id="c4f2" class="graf graf--p graf-after--p">Давайте создадим проект:</p><pre name="129f" id="129f" class="graf graf--pre graf-after--p">ng new angular-ngrx —style=scss</pre><p name="aad9" id="aad9" class="graf graf--p graf-after--pre">Давайте добавим библиотеки <code class="markup--code markup--p-code">ngrx</code>, которые мы будем использовать:</p><pre name="f314" id="f314" class="graf graf--pre graf-after--p">npm install @ngrx/core @ngrx/store @ngrx/effects @ngrx/store-devtools @ngrx/router-store --save</pre><p name="f339" id="f339" class="graf graf--p graf-after--pre">Мы устанавливаем почти все библиотеки экосистемы <code class="markup--code markup--p-code">ngrx</code>. Названия большинства из них совершенно ясно представляют их назначение. Например, ядро <code class="markup--code markup--p-code">core</code>, хранилище <code class="markup--code markup--p-code">store</code>, эффекты <code class="markup--code markup--p-code">effects</code>. Но есть пара, которая может удивить вас своим предназначением.</p><ul class="postList"><li name="a60d" id="a60d" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">store-devtools</code> — мощная утилита для отладки.</li><li name="1bee" id="1bee" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">router-store</code> — сохраняет состояние маршрутизатора Angular в хранилище.</li></ul><h4 name="e3c8" id="e3c8" class="graf graf--h4 graf-after--li">Структура папок хранилища</h4><p name="b78a" id="b78a" class="graf graf--p graf-after--h4">Давайте начнем с обсуждения файловой структуры хранилища. Эта файловая структура и вся конфигурация хранилища должны быть в <code class="markup--code markup--p-code">core</code> модуле вашего приложения. Но в нашем примере у нас его нет, поэтому хранилище будет расположено в <code class="markup--code markup--p-code">app</code> модуле (действия в значительной степени совпадают, если расположить его в <code class="markup--code markup--p-code">core</code> модуле).</p><figure name="e1af" id="e1af" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 197px; max-height: 195px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 99%;"></div><img class="graf-image" data-image-id="1*t8EbvQSQlYfJBoIAODFFFg.png" data-width="197" data-height="195" src="https://cdn-images-1.medium.com/max/800/1*t8EbvQSQlYfJBoIAODFFFg.png"></div><figcaption class="imageCaption">Структура папок хранилища</figcaption></figure><p name="90f7" id="90f7" class="graf graf--p graf-after--figure">Структура папок представляет фактическую структуру объекта хранилища. У вас будет главная папка с названием «store» и пять вложенных папок, которые представляют каждого из ключевых игроков хранилища: «Actions», «Effects», «Redurs», «Selectors» и «State».</p><h4 name="0967" id="0967" class="graf graf--h4 graf-after--p">Создание состояния и начальных значений</h4><p name="ae1e" id="ae1e" class="graf graf--p graf-after--h4">Как мы уже упоминали ранее, в нашем приложении будет две основных структуры: пользователи <code class="markup--code markup--p-code">users</code> и конфигурация <code class="markup--code markup--p-code">config</code> . Для каждого из них нам нужно создать объект состояния и начальное значение, а также сделать то же самое для состояния приложения <code class="markup--code markup--p-code">app</code>.</p><p name="7603" id="7603" class="graf graf--p graf-after--p">Мы создали два интерфейса для определения объекта пользователя и конфигурации. У нас также есть ещё один для результата HTTP запроса получения объекта пользователя — это просто массив <code class="markup--code markup--p-code">IUser</code>.</p><figure name="7bbc" id="7bbc" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 237px; max-height: 147px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 62%;"></div><img class="graf-image" data-image-id="1*1Xh0ppy2BmU6UdfKNmYu1w.png" data-width="237" data-height="147" src="https://cdn-images-1.medium.com/max/800/1*1Xh0ppy2BmU6UdfKNmYu1w.png"></div><figcaption class="imageCaption">интерфейс IUser</figcaption></figure><figure name="44e8" id="44e8" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 273px; max-height: 106px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 38.800000000000004%;"></div><img class="graf-image" data-image-id="1*almlz4GQpL-yBAYOta4zDw.png" data-width="273" data-height="106" src="https://cdn-images-1.medium.com/max/800/1*almlz4GQpL-yBAYOta4zDw.png"></div><figcaption class="imageCaption">интерфейс IConfig</figcaption></figure><p name="232a" id="232a" class="graf graf--p graf-after--figure">Начнём с состояния пользователя: <code class="markup--code markup--p-code">store/state/user.state.ts</code></p><figure name="837b" id="837b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 507px; max-height: 291px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 57.4%;"></div><img class="graf-image" data-image-id="1*Sd8UJ6nvhtanFaaLut0urA.png" data-width="507" data-height="291" src="https://cdn-images-1.medium.com/max/800/1*Sd8UJ6nvhtanFaaLut0urA.png"></div><figcaption class="imageCaption">Файл описания состояния пользователя</figcaption></figure><p name="c1d2" id="c1d2" class="graf graf--p graf-after--figure">То, что мы сделали здесь очевидно:</p><ul class="postList"><li name="7d26" id="7d26" class="graf graf--li graf-after--p">Создаем и экспортируем интерфейс со структурой состояния пользователя.</li><li name="4a76" id="4a76" class="graf graf--li graf-after--li">Делаем то же самое с начальным значением состояния пользователя, которое реализует <code class="markup--code markup--li-code">implement</code> созданный интерфейс.</li></ul><p name="cc7e" id="cc7e" class="graf graf--p graf-after--li">Для состояния конфигурации мы делаем то же самое <code class="markup--code markup--p-code">store/states/config.state.ts</code>:</p><figure name="c4bb" id="c4bb" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 547px; max-height: 268px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 49%;"></div><img class="graf-image" data-image-id="1*Bwrb5fKhOiJhpwVhikaSPQ.png" data-width="547" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*Bwrb5fKhOiJhpwVhikaSPQ.png"></div><figcaption class="imageCaption">Файл описания состояния конфигурации</figcaption></figure><p name="ad65" id="ad65" class="graf graf--p graf-after--figure">Наконец, нам необходимо сгенерировать состояние приложения <code class="markup--code markup--p-code">store/state/app.state.ts</code></p><figure name="ae6b" id="ae6b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 639px; max-height: 500px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 78.2%;"></div><img class="graf-image" data-image-id="1*K0t-DZDoMhlEIHabAYHQwg.png" data-width="639" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*K0t-DZDoMhlEIHabAYHQwg.png"></div><figcaption class="imageCaption">Файл описания состояния приложения</figcaption></figure><ol class="postList"><li name="01ce" id="01ce" class="graf graf--li graf-after--figure">Состояние приложения содержит состояние пользователя и конфигурации, а также состояние маршрутизатора.</li><li name="9ad4" id="9ad4" class="graf graf--li graf-after--li">Ещё у него есть начальное значение состояния приложения.</li><li name="c08d" id="c08d" class="graf graf--li graf-after--li">Наконец, оно экспортирует функцию получения начального состояния (мы используем её позже).</li></ol><h4 name="2293" id="2293" class="graf graf--h4 graf-after--li">Создание действия</h4><blockquote name="c636" id="c636" class="graf graf--blockquote graf-after--h4">Обязательно прочитайте определение действия, которое мы обсуждали в этой статье.</blockquote><p name="2afc" id="2afc" class="graf graf--p graf-after--blockquote">Нам нужно создать действия для пользователей и настройки. Начнем с действий пользователя <code class="markup--code markup--p-code">store/actions/user.actions.ts</code>:</p><figure name="fa3e" id="fa3e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 751px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 107.2%;"></div><img class="graf-image" data-image-id="1*ZTofBmLIkiMuGw1fyfND3Q.png" data-width="774" data-height="830" src="https://cdn-images-1.medium.com/max/800/1*ZTofBmLIkiMuGw1fyfND3Q.png"></div><figcaption class="imageCaption">Файл с описанием действий пользователя</figcaption></figure><p name="e38a" id="e38a" class="graf graf--p graf-after--figure">Так что это хороший пример действий, которые создаются для функции или сущности <code class="markup--code markup--p-code">entity</code> в нашем приложении. Давайте немного пройдемся по коду:</p><ol class="postList"><li name="e58c" id="e58c" class="graf graf--li graf-after--p">Мы экспортируем объект перечисляемого типа <code class="markup--code markup--li-code">enum</code>, содержащий определение для типов действий. Таким образом, мы избегаем использования произвольного текста, и дублирования кода для типов действий. Это легко порождает ошибки.</li><li name="b724" id="b724" class="graf graf--li graf-after--li">Мы создаем и экспортируем класс для каждого из ваших действий. Все они должны реализовывать интерфейс <code class="markup--code markup--li-code">ngrx/Action</code>. Наконец, мы выбираем для типа действия одно из значений перечисляемого объекта <code class="markup--code markup--li-code">enum</code>. Если вам нужна полезная нагрузка действия <code class="markup--code markup--li-code">payload</code>, вы добавляете её в конструктор класса.</li><li name="835c" id="835c" class="graf graf--li graf-after--li">Наконец, мы экспортируем тип <code class="markup--code markup--li-code">UserActions</code>, содержащий наши классы действий. Это обеспечит нам проверку типов <code class="markup--code markup--li-code">typescript</code>, которую мы можем использовать, например, в наших редукторах <code class="markup--code markup--li-code">reducer</code>.</li></ol><p name="3cc1" id="3cc1" class="graf graf--p graf-after--li">Ну вот всё … создавать действия просто. Давайте посмотрим, как выглядят действия конфигурации <code class="markup--code markup--p-code">store/actions/config.actions.ts</code>:</p><figure name="5244" id="5244" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 559px; max-height: 557px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 99.6%;"></div><img class="graf-image" data-image-id="1*wnXM1jC6BC095inHw0MLHw.png" data-width="559" data-height="557" src="https://cdn-images-1.medium.com/max/800/1*wnXM1jC6BC095inHw0MLHw.png"></div><figcaption class="imageCaption">Файл с описанием действий конфигурации</figcaption></figure><p name="ba91" id="ba91" class="graf graf--p graf-after--figure">Здесь нет ничего нового, и вы, скорее всего, теперь можете легко понять содержимое файла.</p><p name="6c95" id="6c95" class="graf graf--p graf-after--p">Отлично, мы уже определили состояние и действия … давайте создадим редукторы!</p><h4 name="5131" id="5131" class="graf graf--h4 graf-after--p">Создание редукторов (reducers)</h4><blockquote name="d10d" id="d10d" class="graf graf--blockquote graf-after--h4">Обязательно прочтите определение редукторов, которое мы обсуждали в этой статье.</blockquote><p name="df35" id="df35" class="graf graf--p graf-after--blockquote">У нас будут редукторы, реагирующие на некоторые действия, потому что другие будут обрабатываться эффектами, которые мы собираемся реализовать позже.</p><p name="1100" id="1100" class="graf graf--p graf-after--p">Нам понадобится редуктор для пользователей и другой для конфигурации, но нам также понадобится генерировать редукторы приложений, давайте начнем с рассмотрения редукторов пользователей <code class="markup--code markup--p-code">store/reducers/user.reducers.ts</code>:</p><figure name="b5a6" id="b5a6" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 650px; max-height: 618px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 95.1%;"></div><img class="graf-image" data-image-id="1*B00q4GkyKLE-0tE2P3_Oog.png" data-width="650" data-height="618" src="https://cdn-images-1.medium.com/max/800/1*B00q4GkyKLE-0tE2P3_Oog.png"></div><figcaption class="imageCaption">Файл с описанием редукторов пользователя</figcaption></figure><p name="bbc0" id="bbc0" class="graf graf--p graf-after--figure">Давайте обсудим реализацию:</p><ol class="postList"><li name="7351" id="7351" class="graf graf--li graf-after--p">В объявлении метода редуктора <code class="markup--code markup--li-code">userReducers()</code> указываем параметры состояния и действия пользователя. Метод возвращает состояние, реализующее интерфейс <code class="markup--code markup--li-code">IUserState</code>.</li><li name="ebb1" id="ebb1" class="graf graf--li graf-after--li">Используя оператор <code class="markup--code markup--li-code">switch</code>, выбираем обработчики для каждого возможного типа действия.</li><li name="ba98" id="ba98" class="graf graf--li graf-after--li">В обработчике типа действия возвращаем новый объект, который является результатом слияния старого состояния и нового значения.</li><li name="8a19" id="8a19" class="graf graf--li graf-after--li">У каждого редуктора есть результат по-умолчанию, который просто возвращает состояние без каких-либо изменений.</li></ol><p name="eee0" id="eee0" class="graf graf--p graf-after--li">И это всё. В редукторе больше ничего нет. Давайте посмотрим на редукторы конфигурации <code class="markup--code markup--p-code">state/reducers/config.reducers.ts</code>:</p><figure name="6c01" id="6c01" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 436px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 62.3%;"></div><img class="graf-image" data-image-id="1*DzeklLd6Og-CqjJVr_lujg.png" data-width="725" data-height="452" src="https://cdn-images-1.medium.com/max/800/1*DzeklLd6Og-CqjJVr_lujg.png"></div><figcaption class="imageCaption">Файл с описанием редукторов конфигурации</figcaption></figure><p name="a23c" id="a23c" class="graf graf--p graf-after--figure">Глядя на этот код, вы, вероятно, легко его понимаете, т. к. мы уже это всё обсуждали.</p><p name="a28a" id="a28a" class="graf graf--p graf-after--p">Наконец, давайте посмотрим на редукторы приложения <code class="markup--code markup--p-code">store/reducers/app.reducers.ts</code>:</p><figure name="7229" id="7229" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 615px; max-height: 294px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 47.8%;"></div><img class="graf-image" data-image-id="1*s3Z47L2ERkp-zOBzhKgmvQ.png" data-width="615" data-height="294" src="https://cdn-images-1.medium.com/max/800/1*s3Z47L2ERkp-zOBzhKgmvQ.png"></div><figcaption class="imageCaption">Файл с описанием редукторов приложения</figcaption></figure><p name="86bb" id="86bb" class="graf graf--p graf-after--figure">Здесь мы добавляем все редукторы <code class="markup--code markup--p-code">reducers</code> в связанный список <code class="markup--code markup--p-code">map</code>, обрабатывающий действия приложения. Мы используем тип <code class="markup--code markup--p-code">ActionReducerMap</code> для добавления проверки типов действий. Позже мы предоставим <code class="markup--code markup--p-code">provide</code> редукторы этого приложения в модуле <code class="markup--code markup--p-code">angular module</code> хранилища.</p><p name="f888" id="f888" class="graf graf--p graf-after--p">Отлично!… Теперь у нас есть наше состояние, наши действия, наши редукторы, но нам всё ещё нужны эффекты и селекторы. Давайте добавим наши эффекты …</p><h4 name="04fd" id="04fd" class="graf graf--h4 graf-after--p">Создание эффектов</h4><blockquote name="b1b5" id="b1b5" class="graf graf--blockquote graf-after--h4">Обязательно прочтите определение «Эффектов», которое мы уже обсуждали в этой статье.</blockquote><p name="8f3b" id="8f3b" class="graf graf--p graf-after--blockquote">Вы, наверное, уже заметили, что в редукторах мы не обрабатываем все действия, которые мы создали. Это потому, что мы собираемся обработать пропущенные действия в эффектах, потому что эти действия имеют побочные эффекты.</p><p name="1940" id="1940" class="graf graf--p graf-after--p">Давайте начнем с пользовательских эффектов <code class="markup--code markup--p-code">store/effects/user.effects.ts</code>:</p><figure name="8727" id="8727" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 635px; max-height: 895px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 140.9%;"></div><img class="graf-image" data-image-id="1*xzZchv9C-e9R0KTi_TfHog.png" data-width="635" data-height="895" src="https://cdn-images-1.medium.com/max/800/1*xzZchv9C-e9R0KTi_TfHog.png"></div><figcaption class="imageCaption">Файл с описанием эффектов пользователя</figcaption></figure><p name="0adf" id="0adf" class="graf graf--p graf-after--figure">В этом файле у нас много чего происходит. Давайте попробуем объяснить это:</p><ol class="postList"><li name="e41a" id="e41a" class="graf graf--li graf-after--p">Мы объявляем наши пользовательские эффекты с помощью декоратора внедряемых зависимостей <code class="markup--code markup--li-code">injectable decorator</code>.</li><li name="30fc" id="30fc" class="graf graf--li graf-after--li">Мы объявляем наши эффекты, используя декоратор эффектов, предоставленный библиотекой <code class="markup--code markup--li-code">ngrx/Effects</code>.</li><li name="1b59" id="1b59" class="graf graf--li graf-after--li">Используя действия, предоставляемые <code class="markup--code markup--li-code">ngrx/Effects</code>, мы собираемся собрать конвейер <code class="markup--code markup--li-code">pipe</code> наших операторов <code class="markup--code markup--li-code">rxjs</code> для этого эффекта.</li><li name="5d99" id="5d99" class="graf graf--li graf-after--li">Следующим шагом является определение типа действия в эффекте с помощью оператора <code class="markup--code markup--li-code">ofType</code>.</li><li name="ef02" id="ef02" class="graf graf--li graf-after--li">Следующие части представляют собой операторы <code class="markup--code markup--li-code">rxjs</code>, которые мы используем для получения того, что нам нужно (<a href="https://ngrx.io/docs" data-href="https://ngrx.io/docs" class="markup--anchor markup--li-anchor" rel="noopener nofollow noopener" target="_blank">Документация ngrx</a> <a href="https://stackblitz.com/edit/rxjs-aj4vwd" data-href="https://stackblitz.com/edit/rxjs-aj4vwd" class="markup--anchor markup--li-anchor" rel="noopener nofollow noopener" target="_blank">Справочник RxJS</a>).</li><li name="2dbf" id="2dbf" class="graf graf--li graf-after--li">Наконец, в последнем операторе <code class="markup--code markup--li-code">Effect</code> собирается отправить другое действие</li><li name="a9b7" id="a9b7" class="graf graf--li graf-after--li">В конструкторе мы внедряем сервисы, которые собираемся использовать, действия для <code class="markup--code markup--li-code">ngrx/effects</code> и, в данном случае, хранилище (учтите, что это демонстрационная версия, и мы получаем выбранного пользователя из списка пользователей в нашем локальном хранилище)</li></ol><p name="e0ae" id="e0ae" class="graf graf--p graf-after--li">Это в значительной степени та же самая структура, которую вы увидите в любом описании эффекта. В этом случае мы отправляем только успешное действие, но мы можем отправлять ошибки или любое другое состояние, которое мы хотим обработать в наших редукторах приложений.</p><p name="356b" id="356b" class="graf graf--p graf-after--p">Давайте посмотрим на эффекты конфигурации <code class="markup--code markup--p-code">store/effects/config.effects.ts</code>:</p><figure name="0122" id="0122" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 490px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 70%;"></div><img class="graf-image" data-image-id="1*L3EhDJWhCEsmDpnDKNP0rw.png" data-width="800" data-height="560" src="https://cdn-images-1.medium.com/max/800/1*L3EhDJWhCEsmDpnDKNP0rw.png"></div><figcaption class="imageCaption">Файл с описанием эффекта конфигурации</figcaption></figure><p name="1f44" id="1f44" class="graf graf--p graf-after--figure">И снова, вы, вероятно, чувствуете себя комфортно читая этот код.</p><p name="41c9" id="41c9" class="graf graf--p graf-after--p">Теперь пришло время поговорить о селекторах …</p><h4 name="0d89" id="0d89" class="graf graf--h4 graf-after--p">Создание селекторов (selectors)</h4><blockquote name="91ba" id="91ba" class="graf graf--blockquote graf-after--h4">Обязательно прочитайте определение Селекторов, которое мы обсуждали в этой статье.</blockquote><p name="493f" id="493f" class="graf graf--p graf-after--blockquote">Нет смысла повторять получение фрагментов нашего состояния повсеместно, поэтому давайте создадим селекторы, которые можно использовать повторно.</p><p name="628b" id="628b" class="graf graf--p graf-after--p">Как всегда, давайте сначала посмотрим на пользовательские селекторы <code class="markup--code markup--p-code">store/selectors/user.selector.ts</code>:</p><figure name="9caa" id="9caa" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 529px; max-height: 387px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 73.2%;"></div><img class="graf-image" data-image-id="1*zHhjZ5HpK71-z9FBuXa-Tg.png" data-width="529" data-height="387" src="https://cdn-images-1.medium.com/max/800/1*zHhjZ5HpK71-z9FBuXa-Tg.png"></div><figcaption class="imageCaption">Файл с описанием селекторов пользователя</figcaption></figure><p name="14eb" id="14eb" class="graf graf--p graf-after--figure">Этот код просто понять, потому что мы не делаем никаких преобразований данных в наших селекторах. Вместо этого мы возвращаем фрагмент хранилища, на который ссылается селектор, используя функцию <code class="markup--code markup--p-code">createSelector</code> из <code class="markup--code markup--p-code">ngrx/store</code>.</p><p name="1a45" id="1a45" class="graf graf--p graf-after--p">Первый параметр — это фрагмент хранилища, которое будет использоваться для получения данных (это может быть массив с несколькими объектами состояния), второй параметр — это анонимная функция, которая будет решать, какой селектор возвращать.</p><p name="5f9d" id="5f9d" class="graf graf--p graf-after--p">Вот так создаются селекторы. Давайте посмотрим на хранилище настроек <code class="markup--code markup--p-code">config/selectors/config.selectors.ts</code>:</p><figure name="071a" id="071a" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 529px; max-height: 271px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 51.2%;"></div><img class="graf-image" data-image-id="1*iCNhIeyAh6H93huAZrvC6Q.png" data-width="529" data-height="271" src="https://cdn-images-1.medium.com/max/800/1*iCNhIeyAh6H93huAZrvC6Q.png"></div><figcaption class="imageCaption">Файл с описанием состояния конфигурации</figcaption></figure><p name="fa70" id="fa70" class="graf graf--p graf-after--figure">Как и раньше, вы чувствуете себя комфортно читая этот код.</p><p name="37e2" id="37e2" class="graf graf--p graf-after--p">Мы уже создали всё необходимое для хранилища, но нам нужно собрать всё это вместе.</p><h4 name="fc9f" id="fc9f" class="graf graf--h4 graf-after--p">Настроить всё вместе</h4><p name="06c3" id="06c3" class="graf graf--p graf-after--h4">Отлично, мы создали всё, что нужно нашему хранилищу, но нам пока не хватает одной вещи — собрать всё воедино. Я собираюсь сделать это в модуле <code class="markup--code markup--p-code">app</code>, но вы можете применить то же самое в модуле <code class="markup--code markup--p-code">core</code> вашего приложения.</p><p name="0ef2" id="0ef2" class="graf graf--p graf-after--p">Давайте посмотрим модуль приложения:</p><figure name="e9dd" id="e9dd" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 764px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 109.2%;"></div><img class="graf-image" data-image-id="1*c9z3sp3aTbYehSc7J9_KAA.png" data-width="763" data-height="833" src="https://cdn-images-1.medium.com/max/800/1*c9z3sp3aTbYehSc7J9_KAA.png"></div><figcaption class="imageCaption">Файл с описанием модуля приложения</figcaption></figure><p name="c4e8" id="c4e8" class="graf graf--p graf-after--figure">Давайте перечислим то, что необходимо для настройки нашего хранилища:</p><ol class="postList"><li name="f827" id="f827" class="graf graf--li graf-after--p">Мы импортируем наши редукторы, и передаём их в метод <code class="markup--code markup--li-code">forRoot</code> модуля хранилища.</li><li name="eb52" id="eb52" class="graf graf--li graf-after--li">Мы импортируем наши эффекты, и передаём их внутри массива в метод <code class="markup--code markup--li-code">forRoot</code> модуля эффектов.</li><li name="9b4b" id="9b4b" class="graf graf--li graf-after--li">Мы передаём настройки для модуля состояния маршрутизатора <code class="markup--code markup--li-code">StoreRouterConnectingModule</code>.</li><li name="fb7d" id="fb7d" class="graf graf--li graf-after--li">И мы добавляем инструменты разработчика хранилища <code class="markup--code markup--li-code">StoreDevtoolsModule.instrument()</code>, если запущена среда разработки.</li></ol><p name="4562" id="4562" class="graf graf--p graf-after--li">Первые два шага необходимы, в то время как шаги 3 и 4 я настоятельно рекомендую, но они не являются обязательными.</p><p name="e0f0" id="e0f0" class="graf graf--p graf-after--p">Теперь мы наконец закончили … и можем использовать хранилище в наших компонентах!</p><h4 name="8fc4" id="8fc4" class="graf graf--h4 graf-after--p">Использование хранилища в некоторых компонентах</h4><p name="5704" id="5704" class="graf graf--p graf-after--h4">Может быть, сейчас вы думаете:</p><blockquote name="b44e" id="b44e" class="graf graf--blockquote graf-after--p">Великий Санти, я потратил 20 минут, читая твою статью, я знаю, что мне нужно знать о <code class="markup--code markup--blockquote-code">ngrx</code>: что это такое, когда его использовать, как его настроить … и это здорово, но не могли бы вы показать мне сейчас, как я могу это использовать!</blockquote><p name="10ca" id="10ca" class="graf graf--p graf-after--blockquote">Да, я могу! Пожалуйста, не теряйте интерес, мы приближаемся к концу! Давайте посмотрим, как использовать наше хранилище …</p><p name="3ec8" id="3ec8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Во-первых, давайте получим конфигурацию при запуске приложения:</strong></p><figure name="5672" id="5672" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 526px; max-height: 464px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 88.2%;"></div><img class="graf-image" data-image-id="1*J8aWvXKkpe050EgHUcWlOg.png" data-width="526" data-height="464" src="https://cdn-images-1.medium.com/max/800/1*J8aWvXKkpe050EgHUcWlOg.png"></div><figcaption class="imageCaption">Файл с описание компонента приложения</figcaption></figure><ol class="postList"><li name="6b50" id="6b50" class="graf graf--li graf-after--figure">Мы добавляем хранилище в наш <code class="markup--code markup--li-code">app.component</code>.</li><li name="ee4f" id="ee4f" class="graf graf--li graf-after--li">Мы передаём в <code class="markup--code markup--li-code">config$</code> значение из селектора <code class="markup--code markup--li-code">selectConfig</code>, потому что мы хотим показать часть этой информации в HTML.</li><li name="23d5" id="23d5" class="graf graf--li graf-after--li">В <code class="markup--code markup--li-code">ngOnInit</code> мы отправляем действие, чтобы получить и передать конфигурацию в хранилище.</li></ol><p name="9cf5" id="9cf5" class="graf graf--p graf-after--li">Вот и всё … Мы уже написали код эффекта, который будет обрабатывать это действие, и редуктор, который будет обрабатывать успех этого эффекта. Как только хранилище приобретёт новое состояние, селектор изменит значение нашего свойства. Удивительно!</p><p name="ade4" id="ade4" class="graf graf--p graf-after--p">Вот как мы связываем данные конифгурации в HTML:</p><figure name="630c" id="630c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 446px; max-height: 84px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 18.8%;"></div><img class="graf-image" data-image-id="1*BsniXo3_MTyRumn6d0LE6A.png" data-width="446" data-height="84" src="https://cdn-images-1.medium.com/max/800/1*BsniXo3_MTyRumn6d0LE6A.png"></div><figcaption class="imageCaption">Файл с описанием HTML разметки компонента навигации приложения</figcaption></figure><p name="b5e6" id="b5e6" class="graf graf--p graf-after--figure">Как только у <code class="markup--code markup--p-code">config$</code> изменится значение, мы увидим его в HTML.</p><p name="4543" id="4543" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Теперь давайте посмотрим список пользователей </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">container/users/users.component.ts</strong></code><strong class="markup--strong markup--p-strong">:</strong></p><blockquote name="ac16" id="ac16" class="graf graf--blockquote graf-after--p">Я использую концепции компонентов контейнеров и презентационных компонентов (прим. пер.: умные и тупые компоненты). Если вы не знакомы с этим подходом, посмотрите <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" data-href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" class="markup--anchor markup--blockquote-anchor" target="_blank">здесь</a>.</blockquote><figure name="dd53" id="dd53" class="graf graf--figure graf-after--blockquote"><div class="aspectRatioPlaceholder is-locked" style="max-width: 609px; max-height: 520px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 85.39999999999999%;"></div><img class="graf-image" data-image-id="1*widcv_1aZiaIOLu-iwD9vw.png" data-width="609" data-height="520" src="https://cdn-images-1.medium.com/max/800/1*widcv_1aZiaIOLu-iwD9vw.png"></div><figcaption class="imageCaption">Файл с описанием компонента пользователя</figcaption></figure><ol class="postList"><li name="3d2f" id="3d2f" class="graf graf--li graf-after--figure">Мы собираемся получить список пользователей также как и конфигурацию. Сначала мы внедряем хранилище в компонент пользователя.</li><li name="ca79" id="ca79" class="graf graf--li graf-after--li">В <code class="markup--code markup--li-code">ngOnInit</code> мы отправляем действие, чтобы получить пользователей.</li><li name="a334" id="a334" class="graf graf--li graf-after--li">Мы создаем свойство <code class="markup--code markup--li-code">users$</code>, и присваиваем ему список пользователей, используя селектор <code class="markup--code markup--li-code">selectUserList</code>.</li></ol><p name="384f" id="384f" class="graf graf--p graf-after--li">HTML выглядит так:</p><figure name="4733" id="4733" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 442px; max-height: 45px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 10.2%;"></div><img class="graf-image" data-image-id="1*_2Slw4QqEffWIfzC8yEt_Q.png" data-width="442" data-height="45" src="https://cdn-images-1.medium.com/max/800/1*_2Slw4QqEffWIfzC8yEt_Q.png"></div><figcaption class="imageCaption">Файл с описанием HTML разметки компонента пользователя</figcaption></figure><p name="a4f4" id="a4f4" class="graf graf--p graf-after--figure">Мы отображаем список пользователей в презентационном(тупом) компоненте, и привязываем выбранного пользователя к функции <code class="markup--code markup--p-code">navigateToUser()</code>, которую мы видели в контейнерном(умном) компоненте пользователя ранее.</p><p name="8b06" id="8b06" class="graf graf--p graf-after--p">Отлично… а как мы показываем выбранного пользователя?…</p><p name="b9a0" id="b9a0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Давайте посмотрим на компонент пользовательского контейнера:</strong></p><figure name="da93" id="da93" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 572px; max-height: 498px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 87.1%;"></div><img class="graf-image" data-image-id="1*Izc6VyFsaZWhGAhlh5jIKA.png" data-width="572" data-height="498" src="https://cdn-images-1.medium.com/max/800/1*Izc6VyFsaZWhGAhlh5jIKA.png"></div><figcaption class="imageCaption">Файл с описанием контейнерного компонента пользователя</figcaption></figure><p name="5fa8" id="5fa8" class="graf graf--p graf-after--figure">Этот компонент получает параметр <code class="markup--code markup--p-code">id</code> из <code class="markup--code markup--p-code">ActivatedRoute</code> (текущего url), а с остальным вы, вероятно, уже знакомы. Отправление <code class="markup--code markup--p-code">id</code> в качестве параметра, выбор выбранного пользователя…</p><p name="3d72" id="3d72" class="graf graf--p graf-after--p">Если вы хотите увидеть весь код, просто зайдите в <a href="https://github.com/SantiagoGdaR/angular-ngrx" data-href="https://github.com/SantiagoGdaR/angular-ngrx" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">репозиторий</a> GitHub.</p><p name="0414" id="0414" class="graf graf--p graf-after--p">Для отладки вы можете использовать инструменты разработчика, которые довольно просты в использовании… но данная статья и так уже достаточно подробная, и, я надеюсь, что вы без труда разберетесь с этими инструментами.</p><h4 name="2a14" id="2a14" class="graf graf--h4 graf-after--p">Заключение</h4><p name="dd35" id="dd35" class="graf graf--p graf-after--h4">В этой статье я попытался предоставить ясное и чёткое введение в ngrx, описав всё, что вам нужно знать, чтобы войти в этот мир.</p><p name="db8e" id="db8e" class="graf graf--p graf-after--p">Мы начали объяснять понятия, разбираться, как это работает, зачем оно используется, и, наконец, мы рассмотрели полный базовый пример.</p><p name="705d" id="705d" class="graf graf--p graf-after--p"><a href="https://github.com/SantiagoGdaR/angular-ngrx" data-href="https://github.com/SantiagoGdaR/angular-ngrx" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Вот репозиторий GitHub…</a></p><p name="d445" id="d445" class="graf graf--p graf-after--p">Я рекомендую вам скачать его и немного поиграться с кодом.</p><p name="eb5f" id="eb5f" class="graf graf--p graf-after--p">Я действительно надеюсь, что эта статья поможет вам понять принципы работы <code class="markup--code markup--p-code">ngrx</code>.</p><h4 name="2d7e" id="2d7e" class="graf graf--h4 graf-after--p">Немного благодарностей…</h4><p name="b324" id="b324" class="graf graf--p graf-after--h4">Спасибо <a href="https://medium.com/@leosvel.perez.espinosa" data-href="https://medium.com/@leosvel.perez.espinosa" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">@leosvel.perez.espinosa</a> за то, что он уделил некоторое время обсуждению со мной некоторых функций ngrx и <a href="https://medium.com/@fevialmeida" data-href="https://medium.com/@fevialmeida" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">@fevialmeida</a> за этот невероятный баннер!</p><blockquote name="2599" id="2599" class="graf graf--blockquote graf-after--p graf--trailing">Примечание переводчика: примеры кода дополнены комментариями, исправлены незначительные ошибки, текст незначительно сокращён для более литературно красивого перевода.</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@stepanovv.ru" class="p-author h-card">Валерий</a> on <a href="https://medium.com/p/bdf1c97f44b2"><time class="dt-published" datetime="2019-01-28T08:57:51.047Z">January 28, 2019</time></a>.</p><p><a href="https://medium.com/@stepanovv.ru/angular-ngrx-%D1%8F%D1%81%D0%BD%D0%BE%D0%B5-%D0%B8-%D1%87%D1%91%D1%82%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-bdf1c97f44b2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 16, 2019.</p></footer></article></body></html>