<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Управление состоянием Angular — не бойтесь шаблонов</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Управление состоянием Angular — не бойтесь шаблонов</h1>
</header>
<section data-field="subtitle" class="p-summary">
Бойтесь сильного связывания!
</section>
<section data-field="body" class="e-content">
<section name="6d9c" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="02f6" id="02f6" class="graf graf--h3 graf--leading graf--title">Управление состоянием Angular — не бойтесь шаблонов</h3><h4 name="e001" id="e001" class="graf graf--h4 graf-after--h3 graf--subtitle">Бойтесь сильного связывания!</h4><p name="bb61" id="bb61" class="graf graf--p graf-after--h4"><a href="https://codeburst.io/state-management-in-angular-ee2ccb81c283" data-href="https://codeburst.io/state-management-in-angular-ee2ccb81c283" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Оригинал</a></p><p name="8914" id="8914" class="graf graf--p graf-after--p">Многие люди рассуждают о шаблоне, который создается при внедрении библиотеки управления состоянием на основе redux в приложении Angular. Все, что я могу ответить на это:</p><blockquote name="e42d" id="e42d" class="graf graf--pullquote graf-after--p">Не бойся шаблона. Бойся сильного связывания!</blockquote><p name="1ec4" id="1ec4" class="graf graf--p graf-after--pullquote">Тем не менее, я могу понять таких людей, они в некотором смысле правы. Управление состоянием может очень быстро стать запутанным. Особенно, если вы работаете в большой команде с разным уровнем опыта.</p><p name="8c22" id="8c22" class="graf graf--p graf-after--p graf--trailing">Я думаю, что больше всего боли причиняют шаблоны. Иногда это просто отсутствие четкого разделения интересов. Отсутствие четко определенных умных и глупых компонентов. Состояние, которое не является хорошо структурированным или просто слишком большим, чтобы обрабатываться одним компонентом контейнера. Сложные подписки внутри компонентов, которые могут объединять несколько наблюдаемых потоков(observables).<br>Добавьте сверху некоторые побочные эффекты. Добавьте информацию о маршрутизации в состояние. И внезапно:</p></div></div></section><section name="5d0e" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><figure name="f08d" id="f08d" class="graf graf--figure graf--leading"><div class="aspectRatioPlaceholder is-locked" style="max-width: 524px; max-height: 399px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 76.1%;"></div><img class="graf-image" data-image-id="1*bV5p5HaY65cp4wiba82-Yg.png" data-width="524" data-height="399" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*bV5p5HaY65cp4wiba82-Yg.png"></div><figcaption class="imageCaption">Redux архитектура стала странной</figcaption></figure><p name="3228" id="3228" class="graf graf--p graf-after--figure">Код больше не поддерживаемый. Архитектура Redux обещала решить проблемы сокрытия источника состояния приложения, но теперь стало ещё сложнее следить за потоком данных внутри вашего приложения. Тебя бомбит. Ты винишь того, кто принял решение применить управление состоянием или того, кто его реализовал.</p><blockquote name="e8a8" id="e8a8" class="graf graf--pullquote graf-after--p">Пожалуйста, потерпи немного :)</blockquote><p name="589b" id="589b" class="graf graf--p graf-after--pullquote">В этом посте я покажу как вы можете «управлять» вашей библиотекой управления состоянием. Я буду использовать ngrx в моих примерах, но на самом деле не имеет значения, какую библиотеку на основе редукса вы используете. Концепция остается прежней. Даже простые старые сервисы могут быть использованы для удержания вашего состояния.</p><h4 name="b717" id="b717" class="graf graf--h4 graf-after--p">1. Используй Typescript</h4><p name="b8bf" id="b8bf" class="graf graf--p graf-after--h4">Это лёгкая задача для разработчиков Angular. Стоит к нему немного привыкнуть, и вы уже не сможете без него обходиться. Мы будем использовать его силу, чтобы определять наши типизированные действия и использовать их в редукторах (reducer) и эффектах. Таким образом, ошибки кодирования возникают во время компиляции по мере разработки, а не во время выполнения. Давайте прямо сейчас погрузимся в наши типы действий:</p><figure name="11af" id="11af" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/06814c8d494aa65f42c543cb8ce42227.js"></script><figcaption class="imageCaption">Интерфейсы действий</figcaption></figure><p name="aeab" id="aeab" class="graf graf--p graf-after--figure">Это довольно прямое определение стандартного типа <code class="markup--code markup--p-code">Action</code> , объединяющего типы <code class="markup--code markup--p-code">Type</code> и <code class="markup--code markup--p-code">Payload.</code> Таким образом, фактически каждый объект в форме <code class="markup--code markup--p-code">{type, payload}</code> подтверждает этот тип.</p><p name="a369" id="a369" class="graf graf--p graf-after--p">Мы могли бы использовать это сейчас, чтобы создать функцию, которая возвращает определенное действие и затем отправляет его через ngrx store.dispatch:</p><figure name="5c5d" id="5c5d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/f69d3476ff5dd9636c9dcafb772fd71e.js"></script><figcaption class="imageCaption">функции LoadCommits() ActionCreator()</figcaption></figure><p name="144a" id="144a" class="graf graf--p graf-after--figure">Вопрос закрыт. Это хорошо работает для одной функции конструктора действия, но этого недостаточно. Мы не подумали про редукторы и эффекты, и, когда приложение подрастёт, нам придётся писать много шаблонного и дублирующего кода.</p><p name="d3dd" id="d3dd" class="graf graf--p graf-after--p">Давайте улучшим наш дизайн с помощью функций-фабрик. Они помогают нам немного урезать шаблон:</p><figure name="4528" id="4528" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/2dff0ee787c03eb0ed59ef14c1dcc23f.js"></script><figcaption class="imageCaption">Фабрики</figcaption></figure><p name="1d0c" id="1d0c" class="graf graf--p graf-after--figure">Теперь мы можем использовать <code class="markup--code markup--p-code">createType</code> и <code class="markup--code markup--p-code">createActionCreator</code> для определения наших <code class="markup--code markup--p-code">CommitActions</code>:</p><figure name="3d87" id="3d87" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/f381e71a7ad428f986b25d9aa6460390.js"></script><figcaption class="imageCaption">Действия</figcaption></figure><p name="73a6" id="73a6" class="graf graf--p graf-after--figure">Это альтернатива подходу определения действий на основе классов, который широко применяется пользователями <code class="markup--code markup--p-code">ngrx.</code> Теперь мы готовы отправить действие из компонента контейнера:</p><figure name="b7ce" id="b7ce" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/fd64864ae7c9267743c465af67d2b8ca.js"></script><figcaption class="imageCaption">Отправка действия через ngrx хранилище</figcaption></figure><p name="db0d" id="db0d" class="graf graf--p graf-after--figure">Следующим шагом является настройка редуктора. Самое интересное в редукторах и их эффектах заключается в том, что они поддерживают проверку типов также во время компиляции.</p><figure name="9c34" id="9c34" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/db2c4fdc1001ba58993acb982a02a788.js"></script><figcaption class="imageCaption">Создание редуктора</figcaption></figure><p name="1a78" id="1a78" class="graf graf--p graf-after--figure">Функция <code class="markup--code markup--p-code">isAction</code> не только проверяет соответствие одного из ожидаемых действий, но и позволяет нам использовать типизированную полезную нагрузку внутри операторов <code class="markup--code markup--p-code">is</code> благодаря <a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" data-href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Typescript Type Guards</a>.</p><figure name="6832" id="6832" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/75812bff517604ded49ef82974b724f8.js"></script><figcaption class="imageCaption">Проверка типов действий</figcaption></figure><p name="6435" id="6435" class="graf graf--p graf-after--figure">Тип <code class="markup--code markup--p-code">TypedActionCreator</code> — это функция, которая также сохраняет тип действия как свойство. Это выглядит немного странно, но позволяет нам выполнять проверку <code class="markup--code markup--p-code">isAction</code> без создания дополнительного шаблона.</p><figure name="6e09" id="6e09" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/e09e1f4096be87a5bca7b8ee3238c6dc.js"></script><figcaption class="imageCaption">Конструктор действия</figcaption></figure><p name="1528" id="1528" class="graf graf--p graf-after--figure">Полный исходный код на <a href="https://github.com/yanxch/loading-sample" data-href="https://github.com/yanxch/loading-sample" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">github</a>.</p><h4 name="83bf" id="83bf" class="graf graf--h4 graf-after--p">2. Подумайте о внедрении зависимостей (Dependency Injection)</h4><p name="e3a7" id="e3a7" class="graf graf--p graf-after--h4">Внедрение зависимостей является одной из основных особенностей Angular. Это очень упрощает многое для нас, разработчиков, а именно тестирование и вложенные зависимости. Но за всё надо платить.</p><p name="5141" id="5141" class="graf graf--p graf-after--p">На первый взгляд, внедрение чего угодно куда угодно кажется великим благом. Однако, я тут вижу проблему, которая заключается в том, что разработчики перестают думать о зависимостях. Вот что не даёт мне покоя:</p><blockquote name="7a71" id="7a71" class="graf graf--blockquote graf-after--p">Действительно ли я хочу иметь прямую зависимость от сторонней библиотеки в моем компоненте?</blockquote><p name="92fc" id="92fc" class="graf graf--p graf-after--blockquote">Это подводит нас к сильному связыванию. Связывание — это плохо.</p><p name="04ce" id="04ce" class="graf graf--p graf-after--p">Поэтому мы не хотим иметь прямую зависимость в библиотеке управления состоянием наших компонентов-контейнеров.</p><p name="608d" id="608d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Нет</strong>:</p><p name="12f8" id="12f8" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">— встряхните головой —</em></p><figure name="163d" id="163d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/ffc229c146c5a277edf374869c667f28.js"></script><figcaption class="imageCaption">Сильное связывание</figcaption></figure><p name="5f59" id="5f59" class="graf graf--p graf-after--figure">К сожалению, так делается в каждом онлайн примере <code class="markup--code markup--p-code">ngrx</code> . Если вам сказали, что контейнерные компоненты являются умными, то это не обязательно означает, что они должны импортировать каждую стороннюю библиотеку в качестве зависимости. Есть способ получше.</p><p name="ff4e" id="ff4e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Да</strong>:</p><p name="949e" id="949e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">— кивните одобрительно —</em></p><figure name="5d16" id="5d16" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/7caf62626da1614626885849bf2c99d3.js"></script><figcaption class="imageCaption">Слабое связывание</figcaption></figure><p name="2ab2" id="2ab2" class="graf graf--p graf-after--figure">Теперь вы даже не можете сказать, что за ним стоит ngrx или что мы применяем шаблон <code class="markup--code markup--p-code">redux</code>. Только имена переменных и имена типов позволяют догадаться, что мы используем <code class="markup--code markup--p-code">redux</code>. Но я мог бы переименовать их:</p><figure name="9449" id="9449" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/4b854e8306542c722d717dbad4cd98c8.js"></script><figcaption class="imageCaption">Угадай шаблон redux</figcaption></figure><p name="8294" id="8294" class="graf graf--p graf-after--figure">Должен признать, что мы описали лишь крошечную деталь, и я все еще продолжаю это обдумывать. Мы могли бы переименовать переменные во что-то более знакомое для нашей предметной области (бизнеса).</p><p name="432c" id="432c" class="graf graf--p graf-after--p">Когда мы говорим на языке <code class="markup--code markup--p-code">redux</code>, и находимся в его контексте, термин «действие» (action), безусловно, корректен. Но когда мы в наших контейнерных компонентах говорим на языке бизнеса, то действие больше похоже на <strong class="markup--strong markup--p-strong">команду</strong> (например, <code class="markup--code markup--p-code">LOAD_COMMITS</code>). Когда команда завершена, происходит <strong class="markup--strong markup--p-strong">событие</strong> (например, <code class="markup--code markup--p-code">LOAD_COMMITS_SUCCESS</code>, <code class="markup--code markup--p-code">LOAD_COMMITS_FAILED</code>), основанное на ее результате.</p><p name="035d" id="035d" class="graf graf--p graf-after--p">Выделение зависимостей также помогает нам повысить стабильность тестов. Правило тестов № 1 (по крайней мере для меня) гласит: <strong class="markup--strong markup--p-strong">не макетируй (mock) то, чем не владеешь</strong>. Зачем? Потому что это вне вашего контроля. Если в сторонней библиотеке изменяется что-то, о чем мы не знаем, то это в конечном итоге ломает все наши тесты. <strong class="markup--strong markup--p-strong">Тесты ломаются по неправильной причине</strong>. Они должны сломаться, если кто-то изменит поведение в логике нашего приложения, а не если инструмент управления состоянием изменился.</p><p name="9094" id="9094" class="graf graf--p graf-after--p">У нас должны быть специальные тесты контрактов для проверки интеграции с вашей библиотекой управления состоянием. Тесты должны потерпеть неудачу, если библиотека изменяется неожиданным способом.</p><p name="1c0c" id="1c0c" class="graf graf--p graf-after--p">Что мы выиграли?</p><ul class="postList"><li name="17d9" id="17d9" class="graf graf--li graf-after--p">Слабая связность</li><li name="7573" id="7573" class="graf graf--li graf-after--li">Чистый код</li><li name="04ba" id="04ba" class="graf graf--li graf-after--li">Поддерживаемость</li><li name="f314" id="f314" class="graf graf--li graf-after--li">Хотите заменить свою реализацию <code class="markup--code markup--li-code">redux</code> или текущее решение по управлению состоянием, не сходя с ума? Теперь нет проблем :)</li></ul><p name="7475" id="7475" class="graf graf--p graf-after--li">Но как это вообще работает? Где находится код отправки (dispatch)? Позвольте мне представить вам Связанные действия (<strong class="markup--strong markup--p-strong">Bound Actions</strong>). Это не новая концепция, просто она не получила широкого распространения в сообществе Angular. На это определенно стоит посмотреть.</p><figure name="6a24" id="6a24" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/699beea7aad1305d2730a8b4e2984ed3.js"></script><figcaption class="imageCaption">Конструктор действий</figcaption></figure><p name="7b67" id="7b67" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">CreateBoundActionCreator</code> связывает <code class="markup--code markup--p-code">ActionCreator</code> с функцией отправки (dispatch). Он возвращает функцию, которая принимает полезную нагрузку, затем создает действие и напрямую отправляет его с помощью данной функции отправки. Таким образом, мы можем скрыть зависимость ngrx от вызывающего действия.</p><p name="da05" id="da05" class="graf graf--p graf-after--p">Давайте определим связанное действие в нашем уже существующем классе <code class="markup--code markup--p-code">CommitActions.</code> Для этого класс <code class="markup--code markup--p-code">CommitActions</code> должен стать сервисом Angular, который внедряет хранилище ngrx и затем связывает функцию отправки с функцией действия:</p><figure name="9b9d" id="9b9d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/10c0f9f4bdd175525a13914e29b6e138.js"></script><figcaption class="imageCaption">Связывание действий</figcaption></figure><p name="ee44" id="ee44" class="graf graf--p graf-after--figure">Теперь компонент контейнера больше не имеет прямой зависимости от ngrx. Это то, чего мы хотели достичь.</p><figure name="2ba2" id="2ba2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/7caf62626da1614626885849bf2c99d3.js"></script><figcaption class="imageCaption">Слабое связывание компонента</figcaption></figure><h4 name="2044" id="2044" class="graf graf--h4 graf-after--figure">3. Используй селекторы (selectors)</h4><p name="df41" id="df41" class="graf graf--p graf-after--h4">До сих пор мы только посылали команду, чтобы запустить побочный эффект (отправка HTTP запроса) и, в конце концов, загрузить коммиты в хранилище. Но мы все равно должны показать их пользователю. Для этого мы должны выбрать данные из хранилища <code class="markup--code markup--p-code">Redux</code> в нашем компоненте <code class="markup--code markup--p-code">CommitsContainer</code>. Это можно сделать напрямую, если мы внедрим в него сервис хранилища из ngrx.</p><p name="a506" id="a506" class="graf graf--p graf-after--p">К сожалению, при таком подходе мы снова получаем нежелательную зависимость от нашей библиотеки управления состоянием. Для этого мы создаем сервис <code class="markup--code markup--p-code">CommitSelector,</code> который содержит наши селекторы и может быть внедрен в компонент контейнера, чтобы эффективно скрыть от него зависимость ngrx.</p><figure name="aab2" id="aab2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/1d1a39e18acff935f598a479ba6e7fad.js"></script><figcaption class="imageCaption">Сервис селекторов</figcaption></figure><p name="d648" id="d648" class="graf graf--p graf-after--figure">В <code class="markup--code markup--p-code">CommitsContainer</code> мы теперь можем использовать этот сервис, выбрать данные, и передать их нашему презентационному компоненту в шаблоне:</p><figure name="a308" id="a308" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/9cf57f136ccbbb68e5ccf222a862dffd.js"></script><figcaption class="imageCaption">Внедрение сервиса в компонент</figcaption></figure><figure name="ddef" id="ddef" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/yanxch/4416ee6e1e8913e42134eeba43449d5f.js"></script><figcaption class="imageCaption">Шаблон компонента коммитов</figcaption></figure><p name="be73" id="be73" class="graf graf--p graf-after--figure">Еще одна действительно приятная особенность селекторов — возможность их комбинировать. Таким образом, несколько простых селекторов могут быть объединены в один сложный. <strong class="markup--strong markup--p-strong">Ngrx</strong> поставляется с модифицируемыми функциями <code class="markup--code markup--p-code">createSelector</code>. Но вы также можете использовать библиотеку <a href="https://github.com/reduxjs/reselect" data-href="https://github.com/reduxjs/reselect" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">reselect</a>.</p><p name="9ad9" id="9ad9" class="graf graf--p graf-after--p">Давайте посмотрим на пример. В приведенном выше коде мы захардкодили имя пользователя. Теперь мы хотели бы передать его динамически через параметр url-маршрута.</p><p name="e487" id="e487" class="graf graf--p graf-after--p">Я расширил пример использования <code class="markup--code markup--p-code">ngrx/router-store</code> для синхронизации текущего состояния маршрутизатора (angular/router) с нашим хранилищем <strong class="markup--strong markup--p-strong">ngrx.</strong> Это позволяет нам использовать мощность комбинированных селекторов, где <code class="markup--code markup--p-code">routeSelector</code> извлекает состояние маршрутизатора из хранилища, а <code class="markup--code markup--p-code">routeParamSelector</code> считывает из него переданный параметр маршрута.</p><figure name="44ef" id="44ef" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/f70a4e6559524774d034ea0e01df4ee4.js"></script><figcaption class="imageCaption">Комбинирование селекторов</figcaption></figure><p name="62eb" id="62eb" class="graf graf--p graf-after--figure">Теперь мы можем использовать селектор в нашем сервисе <code class="markup--code markup--p-code">CommitSelectors</code>:</p><figure name="c9a1" id="c9a1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/b096451eb21d8247619bd2b026525118.js"></script><figcaption class="imageCaption">Сервис селекторов</figcaption></figure><p name="bc6c" id="bc6c" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">CommitsContainer</code> описывает наблюдаемое (observable) имя пользователя и при каждом изменении выполняет действие <code class="markup--code markup--p-code">loadCommits</code>:</p><figure name="9ac2" id="9ac2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yanxch/9e07f2794d4b5510c243288ef4ec8b95.js"></script><figcaption class="imageCaption">Подписка на изменяемое имя пользователя</figcaption></figure><p name="b482" id="b482" class="graf graf--p graf-after--figure">Мы разработали компонент, который не имеет прямой зависимости ни от маршрутизатора, ни от библиотеки управления состоянием. Это важный шаг для получения обслуживаемого, тестируемого и более чистого кода, который более чётко выражает сферу его деятельности.</p><p name="fa3a" id="fa3a" class="graf graf--p graf-after--p">В следующем посте я, вероятно, сделаю еще один шаг и представлю <code class="markup--code markup--p-code">ConnectMixin</code>, который эффективно превратит наши контейнерные компоненты в глупые, которые просто используют <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0"><a href="http://twitter.com/Input" data-href="http://twitter.com/Input" class="markup--anchor markup--p-anchor" title="Twitter profile for @Input" rel="noopener" target="_blank">@Input</a>()</code> и <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0"><a href="http://twitter.com/Output" data-href="http://twitter.com/Output" class="markup--anchor markup--p-anchor" title="Twitter profile for @Output" rel="noopener" target="_blank">@Output</a>()</code> для подключения к хранилищу.</p><p name="6dcc" id="6dcc" class="graf graf--p graf-after--p">Посмотрите полный исходный код на <a href="https://github.com/yanxch/loading-sample" data-href="https://github.com/yanxch/loading-sample" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">github</a>.</p><p name="c949" id="c949" class="graf graf--p graf-after--p">Подпишись на меня в <a href="https://twitter.com/y_a_n_x" data-href="https://twitter.com/y_a_n_x" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">Twitter</em></a> :)</p><blockquote name="35cf" id="35cf" class="graf graf--blockquote graf-after--p graf--trailing">Примечание переводчика: примеры кода дополнены комментариями, исправлены незначительные ошибки, текст незначительно сокращён для более литературно красивого перевода.</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@stepanovv.ru" class="p-author h-card">Валерий</a> on <a href="https://medium.com/p/713f78fa1f00"><time class="dt-published" datetime="2019-02-06T14:11:52.506Z">February 6, 2019</time></a>.</p><p><a href="https://medium.com/@stepanovv.ru/%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC-angular-%D0%BD%D0%B5-%D0%B1%D0%BE%D0%B9%D1%82%D0%B5%D1%81%D1%8C-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2-713f78fa1f00" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 16, 2019.</p></footer></article></body></html>