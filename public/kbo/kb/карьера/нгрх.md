 ## машина состояний

 
редукс - не некая ORM, а набор бойлерплейтов(прямо в разных файлах), который нужно будет сопровождать болльше чем бизнес-логику всего приложения. Редукс - не инструмент, а ядро всего приложения. Есть, например, ngx, который как ангуляр кли автоматизирует создание бойлерплейтов, но, в любом случае, мы платим увеличением кодовой базы в несколько раз. Это очень большая цена.

Машина состояний - это конечные автоматы. Математическая теоря, которой уже много лет. Если прикинуть, что основная архитектура модулей приложения - вертикальный однонаправленный граф, то конечные автоматы нужны для доставки/обработки состояний в горизонтальной плоскости. Т.е. когда мы либо не можем, либо не успеваем нормально рефакторить код вертикального графа зависимостей. Вторая жёсткая необходимость автоматов - гарантированная доставка при условии соблюдения порядка в сложной логике взаимодействия. Если нужно просто гарантированно доставить - есть библиотеки очередей.

Потому считаю, что обоснование необходимости увеличения кодовой базы должно быть очень крепким и увесистым.
Погружаясь дальше, могу отметить, что редукс объединяет в себе CRUD базу, машину автоматов и шину событий. Вот это объединение и тянет за собой увеличение кодовой базы. Обоснование должно включать необходимость переплетения этих сущностей.

Для успеха проекта в целом желательно, чтобы решение было крепко обосновано. Моё предложение - отложить внедрение шаблона редукс до момента завершения проектирования значительной части схемы данных(состояний) приложения. В процессе проектирования станет понятно - можем ли мы обеспечить чистую архитектуру без redux.

* если состояния нравится дебажить - либо сложность высокая, либо код слишком плохо организован
* если команда большая - косвенный признак высокой скорости изменений бизнес-логики
* оценить во сколько вырастет кодовая база косвенно помогут советы по лучшим практикам и шаблонизаторы навроде ngx
* фабрики для некоторых элементов ngrx - https://github.com/johnpapa/angular-ngrx-data
* антипаттерн blob https://sourcemaking.com/antipatterns/the-blob
* ttps://github.com/johnpapa/angular-ngrx-data/blob/f29e5ef59c78a7374d7442c549bcb7a1f2935a75/lib/src/reducers/entity-collection-reducer-registry.ts
* ngrx — один глобальный стор
redux — это вообще библиотечка для создания своих сторов, сколько угодно, когда угодно
* сделай пример в императивном стиле как ты предлагаешь в рантайме расширять ngrx. эта задача поможет разобраться с тем, как ngrx работает и запускается, гед генерит бойлерплейт и где границы его гибкости
* генератор конфигов для ngrx https://github.com/aspnetboilerplate/module-zero-core-template/blob/master/angular/src/main.ts https://github.com/aspnetboilerplate/module-zero-core-template/blob/master/angular/src/AppPreBootstrap.ts
* вам в любом месте приложения необходимы любые данные от любой его части? А зачем редукс тогда, если нужен стор с крудом
* SPA начал тормозить - заменил редукс на localForage(это обертка над IndexedDB), после чего тормозить перестало. Избавился от бойлерплейта связанного со редусерами и экшонами, получил нормальный эвентбас и очень быстрый стор с необходимой перифирией. В модулях и смарт-компонентах фактически ничего не поменялось - cqrs обеспечил однонаправленность потока изменений, которым просто заменил диспетчер и подписку редукса. И реально, стало быстро, просто и прозрачно.
*  у нас сейчас 15 разработчиков и то что через redux-devtools можно отследить действия и текущее состояние это большой плюс, особенно если лезешь в модуль который кто-то другой делал
* Если тебе нужно слать в одной форме разные сущности, возможно что-то недодекомпозировали. спроси у Лиса про то как учитываются требования и бэка и фронта на проекте, что если фронту это засаживает сложность, то можно выставить требования к бэку на нужные вещи. И это нормально, если ты только со сторонним апи не работаешь
* если в команде нельзя или не получается быстро согласовывать изменения архитектуры - вам в энгэрэикс
* если команда не может договриться - это тревожный звоночек про плохо организованные процессы либо есть какой-то практический предел, скажем, в 7 человек на фронте, который даже смысла нет оптимизировать по процессам
* Я так понял, что против нгрэикс топят фулстек/одиночки. За - наоборот. Т.е. там, где народу много не думать об архитектуре помогает нгрэикс. Вот ведь костыль какой в критерий оценки по скорости изменений.
* Мы только-только на вторую итеррацию пошли, первая - это был прототип. Т.е. планируем архитектуру в виде набора гипотез и технологий, проверяем их на базе быстрого прототипа, затем смотрим что менять, а что выбрали удачно, корректируем проект и запускаем уже продуктовую разработку. Мы только-только на вторую итеррацию пошли, первая - это был прототип. Т.е. планируем архитектуру в виде набора гипотез и технологий, проверяем их на базе быстрого прототипа, затем смотрим что менять, а что выбрали удачно, корректируем проект и запускаем уже продуктовую разработку.

* с нгрикс можно не заниматься проектированием, а просто фигачить код. платим мы в двух местах: снижается время разработки одного задания(включая исправление ошибок), и падает производительность приложения. Исчезает возможность за счёт архитектуры поправить скорость.
* KISS может быть
DRY точно нет
SOLID точно нет
Если речь про ngrx/ngxs
* По сложности - а какаие альтернативы? Идеоматика конечно есть, но с тем же успехом это может что угодно и оно приобретает статус такой же идеомы. А теперь берем набор разных компонентов, которые не обязатлеьно увязываются в одной идеоме и получаем меньшую сложность для понимания, чем  тот же редукс, увязывающий как минимум 4 различных идеомы в себе. 
То что на больших проекта это окупает - спорно. Зависит в первую очередь от проекта. Ты с одной стороны получаешь стандартизацию, но с другой получаешь связывание этой идеомой архитектуры. И чем больше проект тем в нем больше нестандартных задач, которые ты вынужден адаптировать под редукс. Не наоборот (что было бы логичнее). 
Про обучение новых чуваков уже говорил - их можно учить и не редуксу, в любом случае новый чел будет пару недель минимум втыкать в проект. Редукс там или что-то еще
* Ну вот смари, был у меня год назад небольшой но сложный проект строительного калькулятора. Его суть была примерно в следующем: в админке создаются пресеты комнат и услуг по ремонту (обои там, потолки, линолеум и т.п.). На стороне пользователя ты выбираешь один из пресетов, например "Бюджетный", далее в списке комнат можешь уточнить размеры комнаты, количество окон дверей и т.д. Так же ты можешь добавить или удалить услуги. Рассчитывается все автоматом, например квадратура стен с вычетом проемов, чтобы прикинуть метраж обоев в рулонах. Так же можно удалить или добавить сами комнаты, которые тоже делятся по типам: жилые, нежилые, санузел, кухня и т.д. После того как ты выбрал комнаты и услуги, смету можно посмотреть на отдельной странице. Там таблица с комнатами и услугами по ним. Где ты тоже можешь редактировать услуги - добавить пару рулонов обоев к примеру, на всякий случай. 
Вначале я заюзал там нгрх. И вроде все было норм, кроме того что сперва смета, а затем и комнаты по мере добавления услуг, открывались с тормозами. Проанализировав ситуацию я пришел к выводу, что редукс там не нужен. Хз почему сразу так не сделал, там требования постоянно менялись плюс больше бэком был там занят, чтобы подсунуть правильные данные и эти пресеты. Ну так вот, пошел я и заменил редукс на localForage, после чего страницы просто как пушинки стали порхать. Избавился от бойлерплейта связанного со всеми эти дурацкими редусерами и экшонами, получил нормальный эвентбас и очень быстрый стор с необходимой перифирией. В модулях и смарт-компонентах фактически ничего не поменялось - cqrs обеспечил однонаправленность потока изменений, которым просто заменил диспетчер и подписку редукса. И реально, стало быстро, просто и прозрачно.
* Есть конструктор бойлерплейтов в рантайм, но он требует соблюдения сетевых CRUD контрактов, т.е. использовать многообразие get/post/patch/delete. https://habr.com/ru/post/418369/