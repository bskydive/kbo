# От дизайна до кода без совещаний. Страшная сила красоты.
# Трудно быть стартапом. Часть 3.

![картинка](arkanar-beauty.jpeg)

Демонстрация красоты и богатства на Арканарский манер. Кадр из фильма "Трудно быть богом" по рассказу братьев Стругацких

## введение

Статья получилась длинной сборной из нескольких тем: дизайн, проектирование, апи. Эти темы крепко, но неочевидно связаны, т.к. их связь построена через несколько, обычно последовательных, ролей. Кроме того, рассматривая их в одной статье, я даю больше поводов к комбинации и поиску, подходящих в конкретном проекте, очерёдности их рассмотрения.
Для торопливых: мы учимся здесь автоматизировать и ускорять совместную работу над:
* [дизайном/макетом](https://www.youtube.com/playlist?list=PLM2Q6lcZo4MexclJrYxA0Is42qWBBuHpB)
* [разработкой](https://drive.google.com/file/d/1pzX_z1zasMKX8ZKJ90BpsI0curb2ka-a/view?usp=sharing) макета, фронта и тыла через [макет](https://www.figma.com/file/xzyZ3aWHP3t0Sh4hW2Psvm/gbook-dark-green?node-id=83131%3A0) или [схему](https://drive.google.com/file/d/126bf-4MQwgwjX-jLlTpnCQ0ZIvsr-Dm-/view?usp=sharing)
* [генерацией кода](https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore) сервисов апи через спецификацию и [специальные IDE](https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates).
Для более основательных расширим и углубим далее.

## в поисках идеала

Предположим, что мы делаем приложение для пользователей. Как же заставить пользователей рассказать какое приложение им нужно? Ну то есть поговорить-то можно, однако нельзя на выходе разговора получить технический документ. А ещё более нельзя получить документ, который продержится хотя бы год после составления без правок. С одной стороны, пользователи не могут быть поголовно аналитиками, чтобы писать понятно для разработчиков, с другой - психологами, чтобы осознавать свои потребности, с третьей - экономистами, чтобы прогнозировать ограничения своих потребностей хотя бы на год вперёд.

Между пользователем и разработчиком обычно пролегает пропасть. Потому и выстраивается длинная цепочка из специалистов в виде живого моста через неё. В пространстве моста играется игра "испорченный телефон", во времени - [сказка о его потере](https://www.youtube.com/watch?v=rmyF-XTrHeU). Возникает понятный соблазн разрубить этот гордиев узел волевым решением. Посмотреть на соседский огород, подтянуть здравый смысл, сделать продукт удобным и красивым. Именно с красоты проще всего начать проектирование. Она понятна, не требует специальных знаний, и выпытывания требований из "бизнеса". Необходимость думать можно заменить на "у всех так" и "ну очевидно же". Вот тут появляются менеджеры/владельцы/лиды, которые и берут на себя бремя принятия решений. А проще говоря угадывают, рискуют предположить как будет хорошо и пользователям, и команде разработки. Как сделать нечто полезное, и не слишком сложное в реализации, чтобы успеть в срок.

Отсюда вытекает простое следствие. Аксиома: дизайн должен нравиться тем кто берёт на себя роль ценителя красоты. И второе мгновенное озарение: если потребности пользователя могут внезапно меняться, то дизайн тоже должен подвергаться изменениям. Смирившись с этим, нам остаётся лишь найти способ как генерировать дизайн, который сразу нравится рисковым ценителям.

С чего же начать? Ну, есть много вариантов готового дизайна, а ещё лучше - дизайн систем. Можно просто ткнуть пальцем в любой вариант потолще. Однако, придётся за него заплатить, и немного вникнуть в лицензионный договор на предмет коммерческого использования и правок. 4

 * [подборка шаблонов/библиотек 1](https://elements.envato.com/ru/web-templates/admin-templates)
 * [подборка шаблонов/библиотек 2](https://themeforest.net/)
 * [пример большой библиотеки дизайна](https://wonw.xyz/iotask/#all-pages)
 * [пример большой библиотеки дизайна на основе material, с кодом Angular ](http://demo.oxygenna.com/portal)
 * [бесплатный пример реализации тёмной темы с разбором от material.io](https://material.io/design/color/dark-theme.html#implementation)
 * [бесплатный готовый конфигурируемый figma пример библиотеки дизайна material](https://www.figma.com/blog/material-design-figma-styles/)
 * [бесплатный большой набор компонентов material для sketch/figma](https://www.sketchappsources.com/free-source/597-google-material-design-ui-sketch-app.html)

Это - действительно хороший старт, который экономит месяцы поиска "специалиста по UX", которые на моей практике заканчивались нахождением "ну хотя бы по UI", а в итоге - дорисовыванием одного из популярных шаблонов. И ладно бы заканчивалось. Со временем оказывается, что шаблон не нравится, дизайнер занят бесконечным переделыванием деталей, а разработчики помогают разгонять эту весёлую карусель. До тех пор, пока внезапно не заканчиваются деньги.

Чтобы сделать следующие после выбора шаблона/дизайн-системы шаги не напрасными, необходимо договориться о подходе, признаках, которые можно легко выделить "на глаз" из любого варианта дизайна. Без согласований и споров. Можно выбрать несколько похожих шаблонов, которые нравятся ценителю красоты, и на их основе организовать процесс формализации требований: плотно/воздушно, светло/темно/контрастно, горизонтально/вертикально, мобильно/десктопно.

Дизайнеры также практикуют набор и согласование визуальных образцов, которые нравятся в отдельный [mood board](https://studio.everypixel.com/ru/blog/tips-for-creating-mood-boards/) / [inspiration board](https://blog.mann-ivanov-ferber.ru/2018/01/03/mudbord-sozdayom-plany-na-budushhee/).

Можно пойти от обратного - сначала найти дизайнера, но сосредоточиться не на магических навыках-аббревиатурах и толщине портфолио, а на том, что относится к конкретному проекту. Искать дизайнера без готовых требований, значит искать себе приключения с дизайном, который не нравится. И тут возникает проблема с исполнением роли аналитика. Как и кому писать эти требования?

## универсальный диалект

Если двинуться дальше по мосту из мягких тел, от дизайна к разработке, то можно прийти к удивительному выводу. Изменения в дизайне напрямую влияют на апи. Т.е. подвигав кнопочки вы загрузите работой не только фронтальную, но и тыловую часть. Т.е. буквально всех. Может возникнуть потребность поменять архитектуру или инфраструктуру, докупить серверов, нанять ещё разработчиков. А самое плохое, что это всё происходит не внезапным всеобщим озарением, а постепенно, по цепочке, спустя дни, недели, месяцы.

Не хочу вдаваться в подробности конкретных примеров, потому давайте примем за рабочую гипотезу, что "так бывает", и подумаем в каком месте пути "дизайн--фронт--апи--тыл--инфраструктура" можно срезать углы. Сразу подскажу, что позвать всех на совещание - это так себе вариант. Слишком велика разница в языках разных ролей разработки. Их нужно уравнять в понимании, сделать универсальный диалект. 

Самый простой и понятный - это картинки. Совсем картинки показывать нельзя, ведь их информационная ёмкость/скорость небольшая. А вот картинки с текстом - самое то. А конкретнее - схема. Схема того, что одинаково и в картинках дизайнера, и в контрактах апи. Это описание данных, их типов, ограничений, направления. Тогда можно не грузить менеджеров и дизайнеров программированием, а программистов и админов дизайном. Каждая роль увидит один и тот же минимум - поставку данных между сервером и пользователем. 

Я пробовал организовать поверх графического макета стрелочки-циферки(булавочки), которые указывают какие конкретно данные нужно выводить в поля. Не взлетело. 

[указатели типов данных на макете](https://www.figma.com/file/xzyZ3aWHP3t0Sh4hW2Psvm/gbook-dark-green?node-id=83131%3A0)

Лучший вариант - это подобие спецификации, когда согласованную схему отправляют как задание на разработку дизайна, компонентов, апи. Отправляют асинхронно(т.е. всем), что может теоретически в несколько раз ускорить выдачу кода/картинок. 

[модель данных](https://drive.google.com/file/d/126bf-4MQwgwjX-jLlTpnCQ0ZIvsr-Dm-/view?usp=sharing)

Если немного отвлечься от темы, то можно вспомнить о саботажниках. Они найдут как слить всю накопленную экономию. Борьба с саботажем входит в процесс обучения команды совместной работе:
	 * В первую очередь делаем задачи тормозящие работу коллег, т.е. весь проект.
	 * Ищем компромисс, уступаем, договариваемся, держим слово.
	 * Интересуемся проблемами коллег, помогаем, облегчаем и автоматизируем повторяющиеся взаимодействия.

Итак, вернёмся обратно к нашей цепочке разработчиков. Разорвать цепь, т.е. сделать работу асинхронной поможет диалект "модель данных": схемы для связывания полей ввода/вывода в интерфейсе, типов данных на фронте, параметров/контрактов апи. Делаем список количества, типов, ограничений данных с разбивкой по экранам, при необходимости обрисовываем их рамочками, соединяем стрелочками. В итоге согласуется значительно быстрее картинок макетирования, т.к. модель могут сходу понять и/или сделать любые роли в проекте. Самый простой инструмент для одновременной совместной работы над такой моделью - [draw.io из google docs](https://chrome.google.com/webstore/detail/drawio-diagrams/onlkggianjhjenigcpigpjehhpplldkc). Работает в любом chrome/firefox.

Полноценный, упитанный и шелковистый процесс проектирования, конечно должен включать в себя сценарии(use case) работы пользователя, функциональные и не очень требования, ограничения, и много чего ещё. Много месяцев работы команды аналитиков перед тем, как писать первую строчку кода. Тут подразумеется промышленное/коммерческое приложение, не влезающее в "коробочные" решения магазинов и парикмахерских. Ну а самый навороченный вариант, откуда можно бесконечно черпать идеи велосипедостроения - это инструменты проектирования предметной области, например, [Alloy](https://habr.com/ru/company/yandex/blog/457810/).

В более простом варианте необходимо выдать хоть что-то согласованное с ключевыми ролями проекта для реализации дизайна/фронта/тыла. И главное: нельзя приступать к проектированию интерфейса, а тем более нанимать дизайнера без доступного эксперта в предметной области, готовых описаний сценариев и модели данных. Что-то одно должно быть обязательно, иначе будет потеряно много времени. Потому что через некоторое время после явления чудных картинок начнут прилетать внезапные "а вот это мы не сможем".

Неочевидное преимущество. Использование готовых дизайн систем и моделей данных позволяет за счёт упрощения ускорить и затолкать процессы в гибкую методологию. Становится возможным делать короткие итерации с готовым решением на выходе. Иначе эволюция дизайна не успевает за реализацией компонентов, и проект превращается в разнородную массу.

## инструмент творца

Развивая тему изобразительного искусства, необходимо обозреть доступные для творцов инструменты. Ну и поскольку мы имеем в виду стартап/прототип, то инструменты должны быть соответствующие: бесплатные, групповые, кроссплатформенные/облачные. Например, [figma](https://help.figma.com/category/9-getting-started). Единственное существенное её ограничение, с которым мне пришлось бороться - это [отсутствующие шрифты](https://help.figma.com/article/355-manage-missing-fonts). В макетах от креаклов иногда прилетают специфические для Mac/Win/Lin экземпляры, и их необходимо руками доустанавливать. Есть плагин для [поиска](https://www.figma.com/c/plugin/745394880974490845/Missing-Font-Selector) и [замены](https://www.figma.com/c/plugin/738840446766071906/Font-Replacer) таких шрифтов. Есть ещё облачное приложение-компаньон - zeplin, но он не позволяет редактировать макет. Редактор прожорлив, потому стоит проверить [настройки браузера](https://help.figma.com/article/11-configuring-your-browser)

в хорошей статье про разрешение конфликтов между [верстальщиком и дизайнером](https://habr.com/ru/post/464115/) компактно собраны лучшие практики. Пройдёмся по ним, расширим и углубим.

 * [сетка](https://help.figma.com/article/55-layout-grids). Я взял [типовые размеры сетки material](https://material.io/design/layout/responsive-layout-grid.html#breakpoints)
 * дизайн система
	Кроме бесполезных для стартапа [систем](http://www.designsystemsclub.ru/) есть вполне годные для боя. Например, расширенная готовым кодом в одном из топовых фреймворков: [angular material](https://material.angular.io/components/input/examples). 
 * масштабируемые иконки
	добавлю, что они должны быть квадратными. Иначе мы добавляем себе проблем с [визуальным выравниванием](https://habr.com/ru/post/340258/)
 * пространство имён(таксономия). Включая [названия цветов](https://www.colorhexa.com/color-names) на английском, которые сразу позволяют обозначать переменные в css
	В идеале все подписи коммитов, компоненты, переменные, папки, классы должны содержать одинаковые слова для обозначения одинаковых или взаимосвязанных элементов.
	Используется единое пространство имён, чтобы понимать для каких компонентов в других видах файлов написан кусок кода.
	Одинаковые слова должны быть описаны в справочнике, связывающем между собой бизнес-понятия, вёрстку, код, дизайн.
	Менеджер, дизайнер, программист и тестировщик должны одинаково понимать эти слова.

1. Правила именования должны облегчать рефакторинг, чтобы можно было за один раз легко менять названия. 
 * плагины
	отдельно хочу отметить [синхронизацию с гугло таблицами](https://www.figma.com/c/plugin/735770583268406934). Это позволяет передать любому члену команды роль наполнения контентом макетов.
 * совместная работа
 * размер экрана. Есть [плагин figma](https://www.figma.com/c/plugin/732240841094697441/%E2%9A%A1%EF%B8%8F-Viewports), который помогает выбрать наиболее популярные размеры экрана по категориям. Но есть ньюанс, необходимо округлить до 4px или выбрать другой размер базовой сетки, чтобы корректно работало выравнивание набора колонок сетки(модулей) по центру. Есть хитрость: для небьющихся нацело на шаг сетки размеров экрана надо натянуть отдельный слой с сеткой, и увеличить его до ближайшего кратного шагу. Размер родительского контейнера не изменяются, и выравнивание чёткое по центру. Пример: контейнер 1366, слой с сеткой 1368, сетка 4пх + 12 столбцов 80пх по центру

плагины:
 * выбор элементов с одинаковыми атрибутами [similayer](https://www.figma.com/c/plugin/735733267883397781/Similayer). Для изменения, например, цвета. Я использовал для замены захардкоженых цветов на [библиотечные](https://www.figma.com/blog/component-styles-and-shared-library-best-practices/#style-tips).

Вот тут избрали иной подход, когда [дизайнер может заменить верстальщика](https://www.youtube.com/watch?v=AJU9IyIC3cc) при помощи генератора вёрстки(дизайн системы) [whitepaper](https://whitepaper.tools/). В этом случае вообще не используются отдельное рисование макетов, сразу пишется/генерируется код вёрстки. Я не пошёл в эту сторону, т.к. там недостаточно развесистый стартовый комплект элементов, и недостаточно подробные по отношению к material наставления. Это оставляет открытыми риски неудачного/тупикового креатива в процессе согласования. Будет много переделок, и много потерянного времени. Этот инструмент привнёс ощутимые выгоды в крупных проектах. Но в стартапе, в виде +1 требования в вакансии дизайнера он добавляет в и без того переполненную корзину рисков. Впрочем, если дизайнера нет, а имеющийся верстальщик сможет его применить по делу, то это поможет сделать прототип чуть быстрее.

material mdc web https://material.io/develop/web/
* [каталог ](https://material-components.github.io/material-components-web-catalog/#/)
 * []()
 * [подробный видеокурс по figma](https://www.youtube.com/playlist?list=PLM2Q6lcZo4MexclJrYxA0Is42qWBBuHpB)

## система

Реализация макета начинается с выбора размера экрана. Например, экрана макбука заказчика. Но по-хорошему надо смотреть на [устройства пользователей](https://material.io/resources/devices/). Для этого есть удобный [плагин figma](https://www.figma.com/c/plugin/732240841094697441/%E2%9A%A1%EF%B8%8F-Viewports). Также есть простой демонстратор готовых сайтов под [разными экранами](https://material.io/resources/resizer), а есть то же самое для [макетов в figma](https://www.figma.com/c/plugin/743654854885744527/Responsify-%E2%9A%A1%EF%B8%8F)
Выбрав размеры экрана, приступают к [сетке](https://habr.com/ru/post/344910/). В наставлениях [material сетка](https://material.io/design/layout/responsive-layout-grid.html#breakpoints) также описана достаточно полно.
Выбирать надо с учётом контента, но кто же его знает - каким выйдет прототип по гибким методологиям? 
 
## Figma

 * [Правила подготовки макетов в Figma](https://habr.com/ru/post/463061/)
 * [ограничения figma](https://habr.com/ru/post/463181/)

## angular material

[исходники материал](https://github.com/angular/material2/blob/master/src/lib/core/theming/_theming.scss)

### ликбез

 * https://material.angular.io/guide/theming
 * https://material.angular.io/guide/theming-your-components
 * https://github.com/angular/material2/blob/master/src/lib/core/theming/_theming.scss
 * https://material.angular.io/guide/customizing-component-styles
 * http://blog.bogdancarpean.com/create-custom-color-theme-on-angular-material/

### цвета color

 * [генератор палитры material на основе одного цвета](http://mcg.mbitson.com/#!?mcgpalette1=%2330c103&mcgpalette2=%23121212&mcgpalette3=%23000000&themename=gbook-palette)
 * далее делаем тему на основе сгенерированной палитры(primary/secondary/accent) [полное руководство](https://blog.thoughtram.io/angular/2017/05/23/custom-themes-with-angular-material.html)
    и присваиваем на все стили [вручную из переменных палитры](https://stackoverflow.com/questions/47497743/how-to-create-a-custom-color-theme-with-angular5-and-angular-materials)
 * [наставление](https://material.io/design/color/the-color-system.html#color-usage-palettes)
 * [очень ограниченный инструмент для просмотра сгенерированных тем](https://material.io/tools/color/)
 * [подробнее про расширенный набор из 12 категорий цвета](https://material.io/design/material-theming/implementing-your-theme.html)
 
### типографика шрифты font

 * точно так же необходимо сгенерировать пары: размер шрифта+высота строки+толщина, также можно добавить межсимвольные интервалы
 * желательно прикинуть как они будут смотреться на трёх основных фонах: primary/secondary/accent, т.е. комбинация размер+толщина+цвет фона+межсимвольный интервал. Пока я не нашёл инструментов для расчёта таких контрастов.
 * [стандартные коды](https://github.com/angular/material2/blob/master/src/lib/core/typography/_typography.scss)
 * [наставление](https://material.io/guidelines/style/typography.html)
 * [рекомендации по контрасту](https://material.io/design/usability/accessibility.html#color-contrast)
 * [подробнее про 13 категорий текста](https://material.io/design/material-theming/implementing-your-theme.html#typography)
 
### иконки

 * http://google.github.io/material-design-icons/#icon-font-for-the-web
 * https://github.com/google/material-design-icons/blob/master/iconfont/codepoints
 * https://material.angular.io/components/icon/api
* типовая структура svg: 
	```xml
		<svg xmlns="http://www.w3.org/2000/svg" id="path1" viewBox="0 0 24 24">
    		<path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
		</svg>
	```
* Приводить вектор к контуру, без обводок и заливок
* Крайне желательно делать одноцветные, монолитные(единственные) контуры.
* Делать предпросмотр всех вариантов иконок
* Использовать шрифты и цвета из библиотеки

### поля ввода

 * [спецификация состояний поля ввода](https://material.io/design/components/text-fields.html#spec)
 * [общие правила применения состояний](https://material.io/design/interaction/states.html#)

## мелкие детали

 1. сначала лучше использовать как можно более компактные элементы, например, иконки. Тогда их можно легко передвигать в другие компоненты, меню, экраны, и т.д.
 1. делать всплывающие подсказки над элементами для облегчения обучения. Также полезно составить словарь иконок и их стилей для переиспользования. Пользователь получит предсказуемое поведение, а разработчик сэкономит время.
 1. при редактировании одного объекта необходимо затенять/блокировать изменение родительских/дочерних/смежных объектов
 1. компоненты для редактирования информации нежелательно использовать для её отображения, т.к. у них потребуется делать специальный режим "только для чтения", который отличается от "редактирование заблокировано".
 1. резервировать статическое место под появляющиеся кнопки. Всплывающая панель скроет контент, будет необходимо добавить пустое место. Если добавлять панель в текущем потоке динамически - прокрутка прыгнет. Самое надёжное место - справа от заголовка.
 1. избегать второго уровня всплытия(модалок) при использовании всплывающих элементов. Это ударит при попытке сохранить или восстановить состояние пользователя. Проще заменить их на вкладки или новый экран.
 1. всегда показывать состояние управляющих элементов. Скрывать его только в крайнем случае, т.к. это потребует дополнительно добавлять иконки/цвет/текст для отображения состояния в скрытом виде, например, фильтров или сортировки.
 1. результат работы дизайнера должен быть интерактивным, т.е. содержать переходы между меню и экранами, смену состояний. Проще всего это делать в figma/zeplin.
 1. использовать для создания дизайна современные облачные решения, позволяющие групповую работу, интерактив, и библиотеку компонентов. Самые известные - figma/zeplin. Во втором случае нет веб-редактора. На худой конец, можно sketch.
 1. иконки должны быть выложены в виде svg и вписаны в квадрат 32*32 или 64*64, с соблюдением центрирования по обеим осям. Иначе будет ад отступов при попытке их выровнять.
 1. делать интерфейс как можно более плоским и последовательным для исключения ошибок в логике взаимодействия. Меньше модалок, менюшек под иконкой. Если требуется изобретать новые цвета состояний - это тревожный звоночек.
 1. Явно сообщать пользователю где он находится и какую информацию читает/правит. В заголовке модалки, окна, вкладки. Это помогает вылавливать ошибки при восстановлении состояния из хранилища при перезагрузке.
 1. Сохранять состояние элементов конкретного пользователя при перезагрузке страницы. Лучше всего в local/session storage. Url использовать ограниченно, только для навигации, т.к. он автоматом сливается в гугл/яндекс/и т.п.. Т.е. его нельзя очистить при потере авторизации. Т.е. в url храним id и маршрут открытых/выделенных элементов, чтобы пользователь мог сохранить ссылку в закладки или поделиться. Данные - в хранилище.
 1. дизайн экранов должен быть согласован со всеми членами команды, владеющими предметной областью.
 1. Предпочтительнее выключать компоненты с затенением, чем делать их исчезающими. Это упрощает тестирование и вёрстку, снижает вероятность ошибок.
 1. Избегать блеклых тонов для элементов управления, чтобы их можно было затенять.
 1. для svg: попадайте  в pixel-grid, только целые значения position и size, не используйте для svg Rotate или Flip, переводите все контуры или шрифты для svg в заливку, сводите слои


## пишем апи и код

Как только отгремели согласования параметров графического макета, аналитики, и устоялся набор моделей/схем данных, можно приступать к реализации собственно дизайна макетов, фронта, и тыла. Для фронта и тыла маловато простеньких схемок, поскольку они конвертируются в итоге в развесистую спецификацию апи. Там не только про данные, но и про безопасность, состояния(коды возврата) и протоколы. Чтобы ускорить процесс необходимо подобрать инструмент, который поможет автоматизировать генерацию простеньких схем в развесистую спеку, в графический портал для просмотра всеми членами команды, и в код специфичный для языков/фреймворков фронта и тыла.

Тогда можно будет удобно организовать совместную асинхронную работу над апи. Можно назначить "основного" мастера апи, кто будет создавать первые версии, и "ведомого", который будет дополнять необходимыми с его стороны/фреймворка прибамбасами. И самое главное - появится менее болезненная перспектива для роста сложности апи, вплоть до микросервисов.

Также есть другие подходы, для более сложных/больших апи. С применением [языка запросов](https://graphql.org/) на фронте вместо статических контрактов. 

```txt
Лирическое отступление.
Здесь речь не про рефакторинг, а про создание приложения с нуля. При создании приложения с нуля, как обычно, и команда создаётся также с нуля. Там не проще получать внезапные вводные от тыловиков. Фронтовику прилетает с двух сторон - со стороны дизайна/аналитики, а также со стороны тыла. Вот, я сделал апи, проверяй, удивляйся.

Приходится на фронте стыковать нестыкуемое. Аналитика не знает про ограничения тыла, тыл не смотрит в картинки и таблицы, и с обоих сторон идёт поток человеческих ошибок. Всё это умножает поток доработок в месте "стыка". Поток доработок не монолитен, он разбит на задачи, к которым добавляются случайные задержки: посмотрел, обсудил, проверил, исправил. Растущий поток доработок сдвигает сроки, толкая вроде бы коллег в позицию конфликта. Создаётся возможность и суровый соблазн/давление спихнуть часть работы на коллегу.
```
## Системы разработки и редактирования API

Я потрогал некоторые из топовых систем. В них, как правило, входят: редактор, линтер, тест-сервер с заглушками, генератор документации, редактор заглушек, тестирование сервера апи. Зачастую функционал разбит на ряд утилит, а также имеется собственный язык для описания api. Также встречаются системы с полноценным мониторингом состояния сервера апи, т.е. автоматика запуска и анализа результатов тестов. Это для больших и взрослых систем.

В редакторах есть разделы: авторизации, моделей/схем, путей, документации. Т.е. они похожи на полноценные IDE.

Нас более всего интересует:
 * Конфигуратор апи - то, что облегчает создание и рефакторинг кода: рубрикатор, подсветка, подстановка.
 * Возможность конвертирования формата в/из [openapi 3.0](https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.md). Это самый популярный формат в облачных порталах и генераторах кода.

Менее интересует:
 * Возможность генерирования SDK - кода frontend/backend, и возможность его использования после генерации без доработки. На все популярные фреймворки/языки генераторы уже написаны как минимум из OpenApi, так что при наличии конвертера проблем возникнуть не должно. Однако их тяжело поддерживать. Поэтому, зачастую они уже [устарели](https://github.com/wing328/swagger-codegen/tree/2.3.0/samples/client/petstore/) по версиям [фреймворка](https://docs.apimatic.io/changelog-by-platform/angularjs/).
 * Возможность формата API разбиваться на файлы, т.е. ссылки/импорты.
 * Ручное тестирование: отправил запрос, посмотрел результат. Часто необходимо при совместной работе над созданием API. Этот функционал может быть вынесен отдельно - в сервер заглушек(mock server) или в онлайн портал с интерактивной документацией типа локального [swagger ui](https://swagger.io/tools/swagger-ui/), онлайн [swagger hub](https://app.swaggerhub.com/sear) или [плагина VSCode](https://marketplace.visualstudio.com/items?itemName=Arjun.swagger-viewer).
 * Переменные окружения. Это важно для защиты информации,чтобы не запостить случайно ключ в репу.

Но вместо них можно найти отдельные генераторы, зачастую они есть в плагинах IDE.
 * [angular 6](https://github.com/cyclosproject/ng-openapi-gen)
 * большой набор, включая [angular 8](https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore)
 * [OpenAPI/Swagger в typescript d.ts](https://github.com/horiuchi/dtsgenerator)
 * [ещё генераторы](https://apis.guru/awesome-openapi3/category.html#sdk)

Конвертеры
 * [онлайн все популярные](https://www.apimatic.io/transformer)
 * [онлайн Swagger 2.0 to OpenAPI 3.0.0](https://mermade.org.uk/openapi-converter)
 * [пачка конвертеров 1](https://apis.guru/awesome-openapi3/category.html#converters)
 * [пачка конвертеров 2](https://apiblueprint.org/tools.html#converters)

Итак, кратенький список из того, что нашёл с бесплатным функционалом.

### VSCode

Самый простой вариант - без лишних плюшек, только код. Можно ожидать рубрикаторов/навигации, подсветки, подстановки кода(code snippets).

 * [openapi](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi)
 * [raml](https://marketplace.visualstudio.com/items?itemName=blzjns.vscode-raml)
 * [mson](https://marketplace.visualstudio.com/items?itemName=vncz.vscode-apielements)

### postman

Текущий флагман, за который в итоге я решил взяться. Уклон в сторону тестирования, есть свой язык автоматизации.

Напрягает:
 * Людоедский интерфейс, жертва рефакторинга. Лучше всего зашли уроки из интерактивного учебника [bootcamp](https://f1dc5e0a-73b7-4848-b796-ed8505670bc3.mock.pstmn.io)
 * нет автосохранения
 * нет встроенного предпросмотра json результата с подсчётом элементов массива и свёртыванием параметров
 * не хватает выбора значений параметров из списка
 * нет подстановки адреса сервера: бой/тест/заглушки
 * нельзя просто выставить апи в интернет без регистрации и смс

Функции:
 * [IDE](https://www.getpostman.com/downloads/) и [веб-версия](https://web.postman.co/) и коллекция шаблонов апи.
 * [Примеры ответов](https://learning.getpostman.com/docs/postman/sending_api_requests/responses) - здесь они называются examples, и очень неудобны к просмотру, открываются только по отдельной кнопке в новой вкладке, хотя ничего не мешает им быть справа в окне response.
 * [экспорт в файл](https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-postman-data)
 * [переменные окружения](https://learning.getpostman.com/docs/postman/environments_and_globals/intro_to_environments_and_globals)
 * мониторинг
 * [qraphQl](https://stackoverflow.com/questions/33793629/postman-how-to-see-request-with-headers-and-body-data-with-variables-substitut)
 * Нужно открыть [консоль](https://stackoverflow.com/questions/33793629/postman-how-to-see-request-with-headers-and-body-data-with-variables-substitut), чтобы посмотреть только что отработавший запрос.
 * Может парсить [апи из curl](https://stackoverflow.com/questions/33793629/postman-how-to-see-request-with-headers-and-body-data-with-variables-substitut)
 * [cli](https://www.npmjs.com/package/newman) для автоматизации CI
 * сделан в [chromium](https://learning.getpostman.com/docs/postman/sending_api_requests/debugging_and_logs), потому жрёт и подтормаживает.
 * есть бета режима, где главным будет язык [схемы API](https://learning.getpostman.com/docs/postman/design_and_develop_apis/introduction_to_apis), на выбор openapi, raml, graphql.

### [blueprint](https://apiblueprint.org/tools.html#editors)

Функции:
 * Текстовый markdown открытый формат MSON
 * [онлайн редактор](https://app.apiary.io/)
 * [пачка офлайн плагинов для редакторов](https://apiblueprint.org/tools.html#editors)
 * привязка к github

### 
 * [https://stoplight.io/]() - Подглючивает, но имеет более понятный интерфейс. Кроме того, он, как и остальные конкуренты postman ориентирован не на развесистый GUI, а на собственный человекопонятный язык описания - API schema, т.е. справа в редакторе сразу видна готовая спецификация. Это может помочь при рефакторинге, замене нескольких параметров одновременно.
 * [apimatic](https://www.apimatic.io/) - есть конвертер форматов и оффлайн редактор.
 * [аналог аннотаций jsdoc](http://apidocjs.com/) - приятная плюшечка.
 * [insomnia](https://insomnia.rest/) - Есть приспособы [для GraphQL](https://support.insomnia.rest/article/61-graphql), экспорт в файл [только своего формата](https://support.insomnia.rest/article/52-importing-and-exporting-data).
 * [apiary](https://apiary.io/) - плагин для [atom](https://atom.io/)

Да, не забываем про то, что это далеко не всё. Вот хорошая [точка старта](https://stackshare.io/api-tools) для поисков утилит для апи.

## схема данных. связь с апи

В данном варианте, когда апи уже по сути создано, мне необходимо выбирать между самодокументируемостью кода, названий параметров и совместимостью с существующим апи. Если написать `isForSale: boolean`вместо `saleability: "NOT_FOR_SALE" | "FOR_SALE" | "FREE";`, то сразу будет понятно о чём речь в любом куске кода фронта. Однако, это потребует написания кода парсера/конвертера значений, и, возможно, затруднит масштабирование параметров апи на другие предметные области. 

Впрочем, это эмулирует реальную боевую ситуацию, когда есть два варианта апи - удобный для фронта, и удобный для тыла. Ну и парсер между ними. Так сложилось, как говорится.
 1. 
 [дизайн система для дизайнера и верстальщика в «Фигме»](https://habr.com/ru/post/464115/)
 [лучшие практики figma](https://www.figma.com/blog/component-styles-and-shared-library-best-practices/)